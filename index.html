<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>CATNOODLE</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Gowun+Dodum&family=Oswald:wght@500;700&display=swap" rel="stylesheet">
    
    <style>
        :root {
            --bg-color: #f5f6fa;
            --board-bg: #2d3436;
            --hole-color: #151819;
            --tray-bg: #ffffff;
            --primary-btn: #4834d4;
            --secondary-btn: #eb4d4b;
            --reset-btn: #636e72; /* Ï¥àÍ∏∞Ìôî Î≤ÑÌäº ÏÉâÏÉÅ */
            --text-color: #2d3436;
            --cell-size: 32px;
            
            /* Modal Colors */
            --modal-bg: #1e1e1e;
            --modal-text: #ffffff;
        }

        * { box-sizing: border-box; }

        body {
            /* ÌïúÍ∏ÄÏùÄ Í≥†Ïö¥ ÎèãÏõÄ, ÏòÅÏñ¥/Ïà´ÏûêÎäî Oswald */
            font-family: 'Oswald', 'Gowun Dodum', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            display: flex; flex-direction: column; align-items: center;
            min-height: 100vh; 
            overflow: hidden; 
            touch-action: none; 
            user-select: none; -webkit-user-select: none;
        }

        /* Ìè∞Ìä∏ Ï†ÅÏö© ÏÑ∏Î∂Ä Ï°∞Ï†ï */
        h1, h2, h3, button, select, .key { font-family: 'Oswald', 'Gowun Dodum', sans-serif; }
        p, li { font-family: 'Gowun Dodum', sans-serif; }

        header { margin: 20px 0 15px; text-align: center; display: flex; align-items: center; gap: 10px; }
        h1 { margin: 0; font-size: 2.2rem; color: #2d3436; font-weight: 700; letter-spacing: 0px; text-transform: uppercase; }
        
        .cat-face { font-size: 2rem; filter: drop-shadow(0 4px 6px rgba(0,0,0,0.1)); }

        .btn-help {
            width: 28px; height: 28px; border-radius: 50%;
            background: #b2bec3; color: white; border: none; font-weight: bold; font-size: 1.2rem; cursor: pointer;
            display: flex; justify-content: center; align-items: center;
            font-family: 'Oswald', sans-serif;
        }

        .controls { display: flex; gap: 8px; margin-bottom: 20px; flex-wrap: wrap; justify-content: center; z-index: 20; }
        select, button.game-btn {
            padding: 10px 16px; border-radius: 6px; border: none; font-size: 0.95rem;
            cursor: pointer; box-shadow: 0 4px 6px rgba(0,0,0,0.1); font-weight: 500; color: white;
            text-transform: uppercase; letter-spacing: 0.5px;
        }
        select { background: #636e72; color: white; font-family: 'Gowun Dodum', sans-serif; }
        .btn-gen { background: var(--primary-btn); }
        .btn-answer { background: var(--secondary-btn); }
        .btn-reset { background: var(--reset-btn); }

        #game-container {
            display: flex; flex-direction: column; align-items: center;
            gap: 25px; width: 95%; max-width: 1100px; padding: 10px;
            height: calc(100vh - 150px);
            overflow-y: auto; 
            touch-action: none; 
        }

        @media (min-width: 850px) {
            #game-container { flex-direction: row; align-items: flex-start; justify-content: center; overflow: visible; }
            #board { margin-top: 0; }
            #tray { width: 420px; height: 520px; }
        }

        #board {
            display: grid;
            grid-template-columns: repeat(11, var(--cell-size));
            grid-template-rows: repeat(5, var(--cell-size));
            gap: 2px;
            background-color: var(--board-bg);
            padding: 10px; border-radius: 12px;
            box-shadow: 0 15px 35px rgba(0,0,0,0.2);
            position: relative; flex-shrink: 0;
            border: 4px solid #dfe6e9;
            touch-action: none;
        }

        .cell {
            width: var(--cell-size); height: var(--cell-size);
            background-color: var(--hole-color);
            border-radius: 50%;
            box-shadow: inset 1px 1px 5px rgba(0,0,0,0.6);
        }

        /* üëª Ghost Piece */
        .ghost-piece {
            position: absolute; display: grid; gap: 2px;
            pointer-events: none; z-index: 50; opacity: 0.5;
            transition: left 0.05s, top 0.05s;
        }
        .ghost-block {
            width: var(--cell-size); height: var(--cell-size);
            border-radius: 50%;
            background-color: white;
            border: 2px dashed rgba(255,255,255,0.9);
        }

        /* ‚¨õ Board Overlay (Win State) */
        #board-overlay {
            position: absolute; top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0, 0, 0, 0.7); /* Îçî ÏßÑÌïú Í≤ÄÏ†ï */
            display: none; 
            justify-content: center; align-items: center;
            z-index: 5000; 
            border-radius: 8px;
            backdrop-filter: blur(2px);
            animation: fadeIn 0.3s ease-out;
        }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }

        #board-message-box {
            background: var(--modal-bg);
            color: var(--modal-text);
            padding: 25px 40px;
            border-radius: 8px; /* Ïã¨ÌîåÌïú Î™®ÏÑúÎ¶¨ */
            text-align: center;
            box-shadow: 0 15px 40px rgba(0,0,0,0.5);
            width: 90%; 
            max-width: 500px;
            border: 1px solid rgba(255,255,255,0.1);
            animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        #board-message-box h2 {
            margin: 0; color: #fab1a0; /* Ìè¨Ïù∏Ìä∏ Ïª¨Îü¨ */
            font-size: 1.8rem; line-height: 1.4;
            letter-spacing: 1px;
        }
        #board-message-box p {
            margin: 15px 0 0; color: #b2bec3; font-size: 1.1rem;
        }

        #tray {
            width: 100%; min-height: 300px; flex-grow: 1;
            background-color: var(--tray-bg);
            border-radius: 12px; position: relative; 
            box-shadow: 0 8px 20px rgba(0,0,0,0.08); border: 2px solid #dcdde1;
            overflow: hidden; touch-action: none; transition: all 0.3s ease;
        }
        
        #tray-overlay {
            position: absolute; top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(255,255,255,0.9);
            display: none; flex-direction: column; 
            justify-content: center; align-items: center; z-index: 50; text-align: center;
        }
        #tray-overlay button {
            padding: 16px 50px; font-size: 1.4rem; background: #2d3436; color: white;
            border: none; border-radius: 8px; cursor: pointer; font-weight: bold;
            box-shadow: 0 10px 20px rgba(0,0,0,0.2);
            font-family: 'Oswald', sans-serif; letter-spacing: 1px;
            transition: transform 0.2s;
        }
        #tray-overlay button:active { transform: scale(0.98); }

        .piece {
            display: grid; gap: 1px;
            cursor: grab; touch-action: none; z-index: 100;
            transition: transform 0.1s; pointer-events: auto;
        }
        .piece.on-board { position: absolute; gap: 2px; }
        .piece.in-tray { position: absolute; transform: scale(0.9); }
        .piece.picked-up {
            position: fixed; cursor: grabbing;
            opacity: 0.95; filter: drop-shadow(0 15px 25px rgba(0,0,0,0.3));
            transform: scale(1.05); pointer-events: none; z-index: 9999;
            gap: 2px; transition: none; 
        }
        .piece.locked { cursor: not-allowed; pointer-events: none; }
        .piece.locked .block {
            border: 1px solid rgba(0,0,0,0.3);
            background-image: repeating-linear-gradient(45deg, rgba(0,0,0,0.15), rgba(0,0,0,0.15) 5px, transparent 5px, transparent 10px);
            filter: brightness(0.9);
        }
        .block {
            width: var(--cell-size); height: var(--cell-size);
            border-radius: 50%;
            box-shadow: inset -4px -4px 8px rgba(0,0,0,0.25), inset 3px 3px 8px rgba(255,255,255,0.4), 1px 1px 2px rgba(0,0,0,0.2);
            border: 0.5px solid rgba(0,0,0,0.1);
        }

        /* ‚¨õ Dark Modal Style */
        .modal-overlay {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.6); z-index: 3000;
            display: none; justify-content: center; align-items: center; backdrop-filter: blur(3px);
        }
        .modal {
            background: var(--modal-bg);
            color: var(--modal-text);
            padding: 30px; 
            border-radius: 8px; /* Îë•Í∑º Ï†ïÎèÑ Ï∂ïÏÜå */
            max-width: 340px; width: 90%; text-align: left;
            box-shadow: 0 20px 50px rgba(0,0,0,0.5);
            border: 1px solid rgba(255,255,255,0.1);
            animation: popIn 0.2s ease-out;
        }
        @keyframes popIn { from { transform: scale(0.95); opacity: 0; } to { transform: scale(1); opacity: 1; } }
        
        .modal h3 { margin-top: 0; margin-bottom: 25px; color: #ffffff; text-align: center; font-size: 1.5rem; letter-spacing: 1px; border-bottom: 1px solid #444; padding-bottom: 15px;}
        
        #helpModal ul { padding-left: 0; list-style: none; font-size: 1rem; color: #b2bec3; line-height: 2.4; margin: 0; }
        #helpModal li { display: flex; align-items: center; justify-content: space-between; border-bottom: 1px solid #333; }
        #helpModal span.key { font-weight: bold; color: #dfe6e9; background: #2d3436; padding: 4px 10px; border-radius: 4px; font-size: 0.85rem; border: 1px solid #555;}
        
        #answerModal, #resetModal { text-align: center; }
        .modal p { font-size: 1.1rem; color: #dfe6e9; margin-bottom: 30px; line-height: 1.6; }
        
        .modal-btn-group { display: flex; gap: 12px; justify-content: center; }
        .modal-btn-group button { 
            flex: 1; padding: 12px; border-radius: 6px; border: none; 
            font-weight: bold; cursor: pointer; font-size: 1rem; 
            font-family: 'Oswald', sans-serif; text-transform: uppercase;
            transition: background 0.2s;
        }
        .btn-yes { background: #e17055; color: white; }
        .btn-yes:hover { background: #d63031; }
        .btn-no { background: #636e72; color: white; }
        .btn-no:hover { background: #b2bec3; color: #2d3436;}
        
        .modal button.close-btn { 
            margin-top: 25px; background: #636e72; width: 100%; border-radius: 6px; 
            padding: 12px; color: white; border: none; font-weight: bold; cursor: pointer;
            font-family: 'Oswald', sans-serif; letter-spacing: 1px;
        }

        #message {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(30, 30, 30, 0.95); color: white;
            padding: 20px 50px; border-radius: 8px;
            display: none; z-index: 6000; text-align: center;
            font-weight: 700; box-shadow: 0 15px 40px rgba(0,0,0,0.5); font-size: 1.3rem;
            white-space: pre-line;
            pointer-events: none;
            border: 1px solid #444;
        }
    </style>
</head>
<body>

<header>
    <h1>CATNOODLE <span class="cat-face">üê±</span></h1>
    <button class="btn-help" onclick="openHelp()">?</button>
</header>

<div class="controls">
    <select id="difficulty">
        <option value="2">EASY (2)</option>
        <option value="4" selected>NORMAL (4)</option>
        <option value="6">HARD (6)</option>
    </select>
    <button class="game-btn btn-gen" onclick="loadNewGame()">GENERATE</button>
    <button class="game-btn btn-reset" onclick="confirmReset()">RESET</button>
    <button class="game-btn btn-answer" onclick="confirmShowAnswer()">ANSWER</button>
</div>

<div id="game-container">
    <div id="board">
        <div id="ghost" class="ghost-piece" style="display:none;"></div>
        <div id="board-overlay">
            <div id="board-message-box">
                <h2>CONGRATULATIONS!</h2>
                <p>CATNOODLE MASTER</p>
            </div>
        </div>
    </div>
    <div id="tray">
        <div id="tray-overlay">
            <button onclick="loadNewGame()">NEW GAME</button>
        </div>
    </div>
</div>

<div class="modal-overlay" id="helpModal" onclick="closeHelp()">
    <div class="modal" onclick="event.stopPropagation()">
        <h3>HOW TO PLAY</h3>
        <ul>
            <li><span>Ï°∞Í∞Å Îì§Í∏∞</span> <span class="key">CLICK / DRAG</span></li>
            <li><span>Îí§ÏßëÍ∏∞</span> <span class="key">R-CLICK / TAP</span></li>
            <li><span>ÌöåÏ†Ñ (90¬∞)</span> <span class="key">WHEEL / 2-FINGER</span></li>
        </ul>
        <button class="close-btn" onclick="closeHelp()">CLOSE</button>
    </div>
</div>

<div class="modal-overlay" id="answerModal" onclick="closeAnswer()">
    <div class="modal" onclick="event.stopPropagation()">
        <h3>ANSWER</h3>
        <p>ÌòÑÏû¨ Í≤åÏûÑÏù¥ Ï¢ÖÎ£åÎê©ÎãàÎã§.<br>Ï†ïÎãµÏùÑ ÌôïÏù∏ÌïòÏãúÍ≤†ÏäµÎãàÍπå?</p>
        <div class="modal-btn-group">
            <button class="btn-no" onclick="closeAnswer()">NO</button>
            <button class="btn-yes" onclick="executeShowAnswer()">YES</button>
        </div>
    </div>
</div>

<div class="modal-overlay" id="resetModal" onclick="closeReset()">
    <div class="modal" onclick="event.stopPropagation()">
        <h3>RESET</h3>
        <p>ÎÜìÏó¨ÏßÑ Ï°∞Í∞ÅÎì§ÏùÑ Î™®Îëê<br>Î™®ÏùåÌåêÏúºÎ°ú ÎêòÎèåÎ¶¨Í≤†ÏäµÎãàÍπå?</p>
        <div class="modal-btn-group">
            <button class="btn-no" onclick="closeReset()">NO</button>
            <button class="btn-yes" onclick="executeReset()">YES</button>
        </div>
    </div>
</div>

<div id="message"></div>

<script>
document.addEventListener('contextmenu', event => event.preventDefault());

const SHAPES_DEF = [
    { id: 0, color: '#f39c12', shape: [[1,0],[1,0],[1,1]] }, 
    { id: 1, color: '#c0392b', shape: [[1,1],[1,1],[0,1]] }, 
    { id: 2, color: '#2980b9', shape: [[1,1,1,1],[1,0,0,0]] }, 
    { id: 3, color: '#ffcccc', shape: [[0,1],[0,1],[1,1],[0,1]] }, 
    { id: 4, color: '#27ae60', shape: [[1,1],[1,1],[0,1]] }, 
    { id: 5, color: '#ffffff', shape: [[1,1],[0,1]] }, 
    { id: 6, color: '#82ccdd', shape: [[1,0,0],[1,0,0],[1,1,1]] }, 
    { id: 7, color: '#fd79a8', shape: [[1,0,0],[1,1,0],[0,1,1]] }, 
    { id: 8, color: '#f1c40f', shape: [[1,0,1],[1,1,1]] }, 
    { id: 9, color: '#8e44ad', shape: [[1],[1],[1],[1]] }, 
    { id: 10, color: '#b8e994', shape: [[1,1],[1,1]] }, 
    { id: 11, color: '#95a5a6', shape: [[0,1,0],[1,1,1],[0,1,0]] } 
];

const SOLUTION_DB = [
    [[7,7,4,4,4,1,1,1,6,6,6],[3,7,7,0,4,4,1,1,5,5,6],[3,3,7,0,0,0,11,8,8,5,6],[3,2,2,2,2,11,11,11,8,10,10],[3,2,9,9,9,9,11,8,8,10,10]]
];

const COLS = 11;
const ROWS = 5;
let cellSize = 32;
let boardState = [];
let answerKey = [];
let pieces = [];
let pickedPieceIdx = null;
let dragOffsetX = 0;
let dragOffsetY = 0;
let isDragging = false;
let startX = 0;
let startY = 0;

let dragStartGridX = -1;
let dragStartGridY = -1;
let lastValidGhostPos = null; 
let globalZIndex = 100;

const boardEl = document.getElementById('board');
const trayEl = document.getElementById('tray');
const trayOverlay = document.getElementById('tray-overlay');
const boardOverlay = document.getElementById('board-overlay');
const ghostEl = document.getElementById('ghost');

// Modals
function openHelp() { document.getElementById('helpModal').style.display = 'flex'; }
function closeHelp() { document.getElementById('helpModal').style.display = 'none'; }
function confirmShowAnswer() { document.getElementById('answerModal').style.display = 'flex'; }
function closeAnswer() { document.getElementById('answerModal').style.display = 'none'; }
function confirmReset() { document.getElementById('resetModal').style.display = 'flex'; }
function closeReset() { document.getElementById('resetModal').style.display = 'none'; }

function executeShowAnswer() {
    closeAnswer();
    boardState = JSON.parse(JSON.stringify(answerKey));
    extractPiecesFromBoard(); 
    renderPieces();
    // Ï†ïÎãµ Î≥¥Í∏∞ ÌõÑ Ïò§Î≤ÑÎ†àÏù¥ Ï≤òÎ¶¨ (ÏÑ†ÌÉùÏÇ¨Ìï≠, Î≥¥ÌÜµ Ï†ïÎãµÎ≥¥Î©¥ Í≤åÏûÑ ÎÅù)
    boardOverlay.style.display = 'flex';
    trayOverlay.style.display = 'flex';
}

function executeReset() {
    closeReset();
    // Í≥†Ï†ïÎêòÏßÄ ÏïäÏùÄ Ï°∞Í∞ÅÎì§Îßå Î≥¥ÎìúÏóêÏÑú Ï†úÍ±∞ÌïòÍ≥† Ìä∏Î†àÏù¥Î°ú Î≥¥ÎÉÑ
    pieces.forEach(p => {
        if (!p.isLocked && p.x !== -1) {
            removePieceFromBoardState(p.currentShape, p.y, p.x);
            p.x = -1; p.y = -1;
        }
    });
    // Ìä∏Î†àÏù¥ ÏúÑÏπò Ïû¨Ï†ïÎ†¨
    randomizeTrayPositions();
    renderPieces();
    showMessage("RESET COMPLETE");
}

function initLayout() {
    const isDesktop = window.innerWidth >= 850;
    const containerWidth = document.getElementById('game-container').offsetWidth;
    const targetWidth = isDesktop ? 650 : containerWidth;
    cellSize = Math.floor((targetWidth - 25) / 11);
    if(cellSize > 50) cellSize = 50; 
    document.documentElement.style.setProperty('--cell-size', `${cellSize}px`);
    createGrid();
    if(pieces.length > 0) renderPieces();
}

function createGrid() {
    boardEl.innerHTML = '';
    for(let i=0; i<ROWS*COLS; i++) {
        const div = document.createElement('div');
        div.className = 'cell';
        boardEl.appendChild(div);
    }
    boardEl.appendChild(ghostEl);
    boardEl.appendChild(boardOverlay); 
}

function loadNewGame() {
    if(pickedPieceIdx !== null) releasePiece();
    trayOverlay.style.display = 'none';
    boardOverlay.style.display = 'none'; 
    
    const randIdx = 0; 
    answerKey = JSON.parse(JSON.stringify(SOLUTION_DB[randIdx]));
    boardState = JSON.parse(JSON.stringify(answerKey));
    extractPiecesFromBoard();
    applyDifficulty();
    
    globalZIndex = 100;
    pieces.forEach(p => p.zIndex = globalZIndex++);

    setTimeout(() => {
        randomizeTrayPositions();
        renderPieces();
    }, 50);
    showMessage("NEW GAME START");
}

function extractPiecesFromBoard() {
    pieces = [];
    for(let id=0; id<12; id++) {
        let coords = [];
        for(let r=0; r<ROWS; r++) {
            for(let c=0; c<COLS; c++) { if(boardState[r][c] === id) coords.push({r, c}); }
        }
        if(coords.length === 0) continue;
        const minR = Math.min(...coords.map(p=>p.r));
        const minC = Math.min(...coords.map(p=>p.c));
        const height = Math.max(...coords.map(p=>p.r)) - minR + 1;
        const width = Math.max(...coords.map(p=>p.c)) - minC + 1;
        let shape = Array(height).fill().map(()=>Array(width).fill(0));
        coords.forEach(p => { shape[p.r - minR][p.c - minC] = 1; });

        pieces.push({
            id: id, color: SHAPES_DEF[id].color, currentShape: shape,
            x: minC, y: minR, trayX: 0, trayY: 0, isLocked: true,
            zIndex: 100
        });
    }
}

function randomizeTrayPositions() {
    const trayW = trayEl.clientWidth || 350;
    const trayH = trayEl.clientHeight || 400;
    const trayPieces = pieces.filter(p => !p.isLocked && p.x === -1);
    
    let placedRects = [];

    trayPieces.forEach(p => {
        const pWidth = p.currentShape[0].length * cellSize;
        const pHeight = p.currentShape.length * cellSize;
        
        let bestX = 10, bestY = 10;
        let found = false;

        for(let i=0; i<50; i++) {
            const rx = Math.random() * (trayW - pWidth - 20);
            const ry = Math.random() * (trayH - pHeight - 20);
            
            let overlap = false;
            for(let rect of placedRects) {
                if(rx < rect.x + rect.w && rx + pWidth > rect.x &&
                   ry < rect.y + rect.h && ry + pHeight > rect.y) {
                    overlap = true;
                    break;
                }
            }
            
            if(!overlap) {
                bestX = Math.max(10, rx);
                bestY = Math.max(10, ry);
                found = true;
                break;
            }
        }
        
        if(!found) {
             bestX = Math.max(10, Math.random() * (trayW - pWidth - 20));
             bestY = Math.max(10, Math.random() * (trayH - pHeight - 20));
        }

        p.trayX = bestX;
        p.trayY = bestY;
        placedRects.push({x: bestX, y: bestY, w: pWidth, h: pHeight});
    });
}

function applyDifficulty() {
    const keepCount = parseInt(document.getElementById('difficulty').value);
    let allIndices = pieces.map((_, i) => i);
    let lockedIndices = [];
    for(let i=0; i<keepCount; i++) {
        let r = Math.floor(Math.random() * allIndices.length);
        lockedIndices.push(allIndices[r]);
        allIndices.splice(r, 1);
    }
    pieces.forEach((p, idx) => {
        if(lockedIndices.includes(idx)) {
            p.isLocked = true;
        } else {
            p.isLocked = false;
            removePieceFromBoardState(p.currentShape, p.y, p.x);
            p.x = -1; p.y = -1;
        }
    });
}

function removePieceFromBoardState(shape, r, c) {
    for(let i=0; i<shape.length; i++) for(let j=0; j<shape[0].length; j++) if(shape[i][j]) boardState[r+i][c+j]=-1;
}

function renderPieces() {
    document.querySelectorAll('.piece').forEach(e => {
        if(pickedPieceIdx === null || e.id !== `p-${pickedPieceIdx}`) e.remove();
    });

    pieces.forEach((p, idx) => {
        if(pickedPieceIdx === idx && document.getElementById(`p-${idx}`)) return;

        const el = document.createElement('div');
        const isInTray = p.x === -1;
        el.className = `piece ${isInTray ? 'in-tray' : 'on-board'} ${p.isLocked?'locked':''}`;
        el.id = `p-${idx}`;
        el.style.gridTemplateColumns = `repeat(${p.currentShape[0].length}, 1fr)`;
        el.style.zIndex = p.zIndex || 100;
        
        p.currentShape.forEach(row => {
            row.forEach(v => {
                const b = document.createElement('div');
                if(v) { b.className = 'block'; b.style.backgroundColor = p.color; }
                else b.style.visibility = 'hidden';
                el.appendChild(b);
            });
        });

        if(!isInTray) placeOnBoard(el, p.x, p.y);
        else {
            el.style.left = `${p.trayX}px`;
            el.style.top = `${p.trayY}px`;
            trayEl.appendChild(el);
        }

        if(!p.isLocked) setupInteraction(el, idx);
    });
}

function placeOnBoard(el, x, y) {
    const gap = 2; const padding = 10; 
    el.style.left = `${padding + x * (cellSize + gap)}px`;
    el.style.top = `${padding + y * (cellSize + gap)}px`;
    boardEl.appendChild(el);
}

function setupInteraction(el, idx) {
    el.addEventListener('mousedown', (e) => handleMouseDown(e, idx, el));
    el.addEventListener('touchstart', (e) => handleTouchStart(e, idx, el), {passive: false});
}

// üìê Core Logic
function getHoveredGridPosition(pieceIdx, el) {
    const p = pieces[pieceIdx];
    const bRect = boardEl.getBoundingClientRect();
    const elRect = el.getBoundingClientRect();
    
    const gap = 2; const padding = 10;
    const relX = elRect.left - bRect.left - padding;
    const relY = elRect.top - bRect.top - padding;
    
    const gx = Math.round(relX / (cellSize + gap));
    const gy = Math.round(relY / (cellSize + gap));
    
    const valid = canPlace(p.currentShape, gy, gx);
    
    return { r: gy, c: gx, valid: valid, pxX: padding + gx*(cellSize+gap), pxY: padding + gy*(cellSize+gap) };
}

function updateGhost(idx) {
    const el = document.getElementById(`p-${idx}`);
    if(!el) return;
    
    const result = getHoveredGridPosition(idx, el);
    const p = pieces[idx];

    if(result.valid) {
        lastValidGhostPos = { r: result.r, c: result.c };

        ghostEl.style.display = 'grid';
        ghostEl.style.gridTemplateColumns = `repeat(${p.currentShape[0].length}, 1fr)`;
        ghostEl.innerHTML = ''; 
        p.currentShape.forEach(row => row.forEach(v => {
            const b = document.createElement('div');
            if(v) b.className = 'ghost-block';
            else b.style.visibility = 'hidden';
            ghostEl.appendChild(b);
        }));
        
        ghostEl.style.left = `${result.pxX}px`;
        ghostEl.style.top = `${result.pxY}px`;
        ghostEl.style.zIndex = globalZIndex + 1; 
    } else {
        lastValidGhostPos = null; 
        ghostEl.style.display = 'none';
    }
}

// üñ±Ô∏è PC Mouse
function handleMouseDown(e, idx, el) {
    e.stopPropagation(); 
    if(e.button === 2) { flipPieceData(idx); return; } 
    if(e.button !== 0) return;
    
    if(pickedPieceIdx !== null) {
        dropPiece(pickedPieceIdx, document.getElementById(`p-${pickedPieceIdx}`));
        return;
    }

    if(pickedPieceIdx === null) {
        pieces[idx].zIndex = ++globalZIndex;
        el.style.zIndex = pieces[idx].zIndex;

        const rect = el.getBoundingClientRect();
        dragOffsetX = e.clientX - rect.left;
        dragOffsetY = e.clientY - rect.top;
        pickUpPiece(idx, el, e.clientX, e.clientY);
    }
}

function pickUpPiece(idx, el, startX, startY) {
    pickedPieceIdx = idx;
    const p = pieces[idx];
    
    dragStartGridX = p.x;
    dragStartGridY = p.y;
    lastValidGhostPos = null; 

    if(p.x !== -1) {
        removePieceFromBoardState(p.currentShape, p.y, p.x);
    }

    el.classList.remove('in-tray', 'on-board');
    el.classList.add('picked-up');
    document.body.appendChild(el);
    el.style.left = `${startX - dragOffsetX}px`;
    el.style.top = `${startY - dragOffsetY}px`;

    document.addEventListener('mousemove', onMouseMove);
    document.addEventListener('wheel', onWheel, {passive: false});
    document.addEventListener('mousedown', onGlobalClick);
    document.addEventListener('touchstart', onGlobalTouchStart, {passive: false}); 
    
    updateGhost(idx);
}

function onMouseMove(e) {
    if(pickedPieceIdx !== null) {
        const el = document.getElementById(`p-${pickedPieceIdx}`);
        el.style.left = `${e.clientX - dragOffsetX}px`;
        el.style.top = `${e.clientY - dragOffsetY}px`;
        updateGhost(pickedPieceIdx);
    }
}

function onWheel(e) {
    if(pickedPieceIdx !== null) { e.preventDefault(); rotatePieceData(pickedPieceIdx); }
}

function onGlobalClick(e) {
    if(pickedPieceIdx !== null) {
        if(e.button === 2) return; 
        dropPiece(pickedPieceIdx, document.getElementById(`p-${pickedPieceIdx}`));
    }
}

function onGlobalTouchStart(e) {
    if(pickedPieceIdx !== null && e.touches.length > 1) {
        e.preventDefault(); 
        rotatePieceData(pickedPieceIdx);
    }
}

function dropPiece(idx, el) {
    const p = pieces[idx];
    let targetR, targetC, isValid;

    if (lastValidGhostPos) {
        targetR = lastValidGhostPos.r;
        targetC = lastValidGhostPos.c;
        isValid = true;
    } else {
        const result = getHoveredGridPosition(idx, el);
        targetR = result.r;
        targetC = result.c;
        isValid = result.valid;
    }
    
    if (isValid) {
        placePieceToBoardState(p.currentShape, targetR, targetC, p.id);
        p.x = targetC; p.y = targetR;
        checkWinCondition();
    } else {
        const trayRect = trayEl.getBoundingClientRect();
        const pieceRect = el.getBoundingClientRect();
        
        const pieceCX = pieceRect.left + pieceRect.width / 2;
        const pieceCY = pieceRect.top + pieceRect.height / 2;

        const insideTray = (
            pieceCX >= trayRect.left &&
            pieceCX <= trayRect.right &&
            pieceCY >= trayRect.top &&
            pieceCY <= trayRect.bottom
        );

        if (insideTray) {
             let newTrayX = pieceRect.left - trayRect.left;
             let newTrayY = pieceRect.top - trayRect.top;

             const trayW = trayEl.clientWidth || 350;
             const trayH = trayEl.clientHeight || 400;
             
             newTrayX = Math.max(-20, Math.min(newTrayX, trayW - 10));
             newTrayY = Math.max(-20, Math.min(newTrayY, trayH - 10));

             p.trayX = newTrayX;
             p.trayY = newTrayY;
             p.x = -1; p.y = -1;
        } else {
            returnToTrayRandomly(p);
        }
    }

    cleanupListeners();
    pickedPieceIdx = null; 
    ghostEl.style.display = 'none';
    lastValidGhostPos = null;
    renderPieces();
}

function returnToTrayRandomly(p) {
    p.x = -1; p.y = -1;
    const trayW = trayEl.clientWidth || 350;
    const trayH = trayEl.clientHeight || 400;
    const pWidth = p.currentShape[0].length * cellSize;
    const pHeight = p.currentShape.length * cellSize;
    p.trayX = Math.random() * (trayW - pWidth - 20) + 10;
    p.trayY = Math.random() * (trayH - pHeight - 20) + 10;
}

function cleanupListeners() {
    document.removeEventListener('mousemove', onMouseMove);
    document.removeEventListener('wheel', onWheel);
    document.removeEventListener('mousedown', onGlobalClick);
    document.removeEventListener('touchstart', onGlobalTouchStart); 
}

// üì± Mobile Logic
function handleTouchStart(e, idx, el) {
    e.preventDefault(); e.stopPropagation();

    if (e.touches.length > 1 && pickedPieceIdx === idx) return;
    if(pickedPieceIdx !== null && pickedPieceIdx !== idx) return;

    pieces[idx].zIndex = ++globalZIndex;
    el.style.zIndex = pieces[idx].zIndex;

    const touch = e.touches[0];
    const touchId = touch.identifier;

    isDragging = false;
    startX = touch.clientX;
    startY = touch.clientY;
    
    const rect = el.getBoundingClientRect();
    dragOffsetX = touch.clientX - rect.left;
    dragOffsetY = touch.clientY - rect.top;

    pickUpPiece(idx, el, touch.clientX, touch.clientY);

    const onTouchMove = (ev) => {
        ev.preventDefault();
        
        let myTouch = null;
        for(let i=0; i<ev.touches.length; i++) {
            if(ev.touches[i].identifier === touchId) {
                myTouch = ev.touches[i];
                break;
            }
        }
        if(!myTouch) return;

        if (Math.abs(myTouch.clientX - startX) > 10 || Math.abs(myTouch.clientY - startY) > 10) {
            isDragging = true;
        }
        
        el.style.left = `${myTouch.clientX - dragOffsetX}px`;
        el.style.top = `${myTouch.clientY - dragOffsetY}px`;
        updateGhost(idx);
    };
    
    const onTouchEnd = (ev) => {
        let myTouchStillActive = false;
        for(let i=0; i<ev.touches.length; i++) {
            if(ev.touches[i].identifier === touchId) {
                myTouchStillActive = true;
                break;
            }
        }
        if(myTouchStillActive) return;

        document.removeEventListener('touchmove', onTouchMove);
        document.removeEventListener('touchend', onTouchEnd);
        
        if(!isDragging) { 
            flipPieceData(idx);
            
            const p = pieces[idx];
            if (dragStartGridX !== -1 && canPlace(p.currentShape, dragStartGridY, dragStartGridX)) {
                placePieceToBoardState(p.currentShape, dragStartGridY, dragStartGridX, p.id);
                p.x = dragStartGridX; 
                p.y = dragStartGridY;
                cleanupListeners();
                pickedPieceIdx = null; 
                ghostEl.style.display = 'none';
                renderPieces();
            } else {
                if(dragStartGridX !== -1) {
                    flipPieceData(idx); 
                    placePieceToBoardState(p.currentShape, dragStartGridY, dragStartGridX, p.id);
                    p.x = dragStartGridX; 
                    p.y = dragStartGridY;
                    cleanupListeners();
                    pickedPieceIdx = null; 
                    ghostEl.style.display = 'none';
                    renderPieces();
                } else {
                    dropPiece(idx, el);
                }
            }
        } else {
            dropPiece(idx, el);
        }
    };
    document.addEventListener('touchmove', onTouchMove, {passive: false});
    document.addEventListener('touchend', onTouchEnd);
}

// Logic Utils
function rotatePieceData(idx) {
    const p = pieces[idx];
    const oldShape = p.currentShape;
    const newShape = rotateMatrix(oldShape);
    p.currentShape = newShape;
    updateVisualsInDrag(idx);
}

function flipPieceData(idx) {
    const p = pieces[idx];
    const oldShape = p.currentShape;
    const newShape = oldShape.map(row => [...row].reverse());
    p.currentShape = newShape;
    updateVisualsInDrag(idx);
}

function updateVisualsInDrag(idx) {
    const p = pieces[idx];
    if(pickedPieceIdx === idx) {
        const el = document.getElementById(`p-${idx}`);
        el.style.gridTemplateColumns = `repeat(${p.currentShape[0].length}, 1fr)`;
        el.innerHTML = '';
        p.currentShape.forEach(row => row.forEach(v => {
            const b = document.createElement('div');
            if(v) { b.className = 'block'; b.style.backgroundColor = p.color; }
            else b.style.visibility = 'hidden';
            el.appendChild(b);
        }));
        updateGhost(idx);
    } else renderPieces();
}

function rotateMatrix(m) {
    const R=m.length, C=m[0].length;
    let n=Array(C).fill().map(()=>Array(R).fill(0));
    for(let r=0; r<R; r++) for(let c=0; c<C; c++) n[c][R-1-r]=m[r][c];
    return n;
}

function canPlace(shape, r, c) {
    for(let i=0; i<shape.length; i++) for(let j=0; j<shape[0].length; j++) 
        if(shape[i][j] && (r+i>=ROWS || c+j>=COLS || r+i<0 || c+j<0 || boardState[r+i][c+j]!==-1)) return false;
    return true;
}
function placePieceToBoardState(shape, r, c, id) {
    for(let i=0; i<shape.length; i++) for(let j=0; j<shape[0].length; j++) if(shape[i][j]) boardState[r+i][c+j]=id;
}

function checkWinCondition() {
    const remainingPieces = pieces.filter(p => p.x === -1).length;
    if(remainingPieces === 0) {
        boardOverlay.style.display = 'flex';
        trayOverlay.style.display = 'flex';
    }
}

function showMessage(t) {
    const m=document.getElementById('message'); m.textContent=t; m.style.display='block';
    setTimeout(()=>m.style.display='none', 2000);
}

window.addEventListener('resize', initLayout);
initLayout();
loadNewGame();
</script>
</body>
</html>
