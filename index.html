<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Kanoodle Master Gen</title>
    <style>
        :root {
            --bg-color: #222;
            --board-bg: #000;
            --hole-color: #333;
            --tray-bg: #1a1a1a;
            --primary-btn: #3498db;
            --secondary-btn: #e74c3c;
            --text-color: #eee;
            --cell-size: 32px;
        }

        body {
            font-family: 'Segoe UI', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            display: flex; flex-direction: column; align-items: center;
            min-height: 100vh; overflow-x: hidden; touch-action: none;
            user-select: none;
        }

        header { margin: 15px 0; text-align: center; }
        h1 { margin: 0; font-size: 1.5rem; color: #fff; }
        p { margin: 5px 0 0; font-size: 0.85rem; color: #aaa; }
        
        .guide {
            background: rgba(255,255,255,0.1);
            padding: 8px 15px; border-radius: 8px;
            margin: 10px 0; font-size: 0.8rem; line-height: 1.4;
            max-width: 90%; text-align: center;
        }
        .guide span { color: #ffd700; font-weight: bold; }

        .controls {
            display: flex; gap: 8px; margin-bottom: 10px;
            flex-wrap: wrap; justify-content: center;
        }

        select, button {
            padding: 8px 14px; border-radius: 20px; border: none; font-size: 0.9rem;
            cursor: pointer; box-shadow: 0 2px 5px rgba(0,0,0,0.3);
            font-weight: 600; color: white;
        }
        select { background: #444; color: white; }
        .btn-gen { background: var(--primary-btn); }
        .btn-check { background: #27ae60; }
        .btn-answer { background: var(--secondary-btn); }

        #game-container {
            display: flex; flex-direction: column; align-items: center;
            gap: 15px; width: 100%; max-width: 600px;
            position: relative;
        }

        #board {
            display: grid;
            grid-template-columns: repeat(11, var(--cell-size));
            grid-template-rows: repeat(5, var(--cell-size));
            gap: 2px;
            background-color: var(--board-bg);
            padding: 10px; border-radius: 12px;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            border: 2px solid #444;
        }

        .cell {
            width: var(--cell-size); height: var(--cell-size);
            background-color: var(--hole-color);
            border-radius: 50%;
            box-shadow: inset 2px 2px 5px rgba(0,0,0,0.8);
        }

        #tray {
            width: 95%; min-height: 160px;
            background-color: var(--tray-bg);
            border-radius: 15px; padding: 15px;
            display: flex; flex-wrap: wrap;
            justify-content: center; align-items: center; gap: 15px;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.5);
            margin-bottom: 30px; border: 1px solid #444;
        }

        .piece {
            position: absolute; display: grid; gap: 2px;
            cursor: grab; touch-action: none; z-index: 100;
            transition: transform 0.1s;
            pointer-events: auto;
        }
        /* PC: ë“¤ê³  ìˆì„ ë•Œ */
        .piece.picked-up {
            cursor: grabbing;
            opacity: 0.9;
            filter: drop-shadow(0 10px 10px rgba(0,0,0,0.5));
            transform: scale(1.05);
            pointer-events: none; /* ë§ˆìš°ìŠ¤ í†µê³¼í•˜ì—¬ ì•„ë˜ cell ê°ì§€ */
            z-index: 9999;
        }
        
        .piece.in-tray { position: relative; transform: scale(0.85); left: auto !important; top: auto !important; }
        .piece.locked { cursor: not-allowed; filter: brightness(0.6); pointer-events: none; }
        
        .block {
            width: var(--cell-size); height: var(--cell-size);
            border-radius: 50%;
            /* ì…ì²´ê° ìˆëŠ” êµ¬ìŠ¬ íš¨ê³¼ */
            box-shadow: inset -3px -3px 6px rgba(0,0,0,0.4), inset 3px 3px 6px rgba(255,255,255,0.4), 1px 1px 2px rgba(0,0,0,0.3);
            border: 1px solid rgba(0,0,0,0.2);
        }

        #message {
            position: fixed; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9); color: white;
            padding: 20px 30px; border-radius: 30px;
            display: none; z-index: 2000; text-align: center;
            font-size: 1.1rem; border: 1px solid #555;
        }
    </style>
</head>
<body>

<header>
    <h1>ğŸ§© Kanoodle Master</h1>
    <div class="guide">
        ğŸ’» <b>PC:</b> í´ë¦­(ë“¤ê¸°/ë†“ê¸°) â€¢ íœ (íšŒì „) â€¢ ìš°í´ë¦­(ë’¤ì§‘ê¸°)<br>
        ğŸ“± <b>Mobile:</b> ë“œë˜ê·¸ â€¢ í„°ì¹˜(íšŒì „) â€¢ ë‘ë²ˆ í„°ì¹˜(ë’¤ì§‘ê¸°)
    </div>
</header>

<div class="controls">
    <select id="difficulty">
        <option value="2">Easy (2ê°œ ê³ ì •)</option>
        <option value="4" selected>Normal (4ê°œ ê³ ì •)</option>
        <option value="6">Hard (6ê°œ ê³ ì •)</option>
    </select>
    <button class="btn-gen" onclick="loadNewGame()">ğŸ”„ ìƒì„±</button>
    <button class="btn-check" onclick="checkSolution()">âœ¨ í™•ì¸</button>
    <button class="btn-answer" onclick="showAnswer()">ğŸ‘€ ì •ë‹µ</button>
</div>

<div id="game-container">
    <div id="board"></div>
    <div id="tray"></div>
</div>

<div id="message"></div>

<script>
/**
 * ğŸ› ï¸ SHAPE DEFINITIONS (55 Holes Perfect Fit)
 * ì´ë¯¸ì§€ ê¸°ë°˜ ìƒ‰ìƒ + 5ì¹¸ 7ê°œ + 4ì¹¸ 5ê°œ êµ¬ì„±
 */
const SHAPES_DEF = [
    // [4ì¹¸] Line (Dark Purple)
    { id: 0, color: '#6A0DAD', shape: [[1,1,1,1]] },
    // [4ì¹¸] Square (White)
    { id: 1, color: '#F0F0F0', shape: [[1,1],[1,1]] },
    // [4ì¹¸] L-Short (Orange)
    { id: 2, color: '#FF8C00', shape: [[1,1,1],[1,0,0]] },
    // [4ì¹¸] Z-Short (Yellow) - Replaces Light Blue to match standard sets better
    { id: 3, color: '#FFD700', shape: [[1,1,0],[0,1,1]] }, 
    // [4ì¹¸] T-Short (Light Purple/Pinkish)
    { id: 4, color: '#DA70D6', shape: [[1,1,1],[0,1,0]] },
    
    // [5ì¹¸] L-Long (Blue)
    { id: 5, color: '#0000FF', shape: [[1,0],[1,0],[1,0],[1,1]] },
    // [5ì¹¸] Cross (Grey)
    { id: 6, color: '#808080', shape: [[0,1,0],[1,1,1],[0,1,0]] },
    // [5ì¹¸] Snake (Cyan)
    { id: 7, color: '#00FFFF', shape: [[1,1,0],[0,1,1],[0,0,1]] },
    // [5ì¹¸] W (Magenta)
    { id: 8, color: '#FF00FF', shape: [[1,0,0],[1,1,0],[0,1,1]] },
    // [5ì¹¸] U (Red)
    { id: 9, color: '#FF0000', shape: [[1,0,1],[1,1,1]] },
    // [5ì¹¸] Y (Salmon)
    { id: 10, color: '#FA8072', shape: [[0,1],[1,1],[0,1],[0,1]] },
    // [5ì¹¸] V (Green)
    { id: 11, color: '#008000', shape: [[1,0,0],[1,0,0],[1,1,1]] }
];

/**
 * ğŸ’¾ SOLUTION DATABASE (11x5 Valid Solutions)
 * ê²€ì¦ëœ ì •ë‹µ ë°ì´í„°ì…‹
 */
const SOLUTION_DB = [
    // Set 1: Standard layout
    [
        [5,5,6,6,6,0,0,0,0,9,9],
        [11,5,5,5,6,3,3,2,2,2,9],
        [11,11,11,7,6,3,3,10,10,2,9],
        [4,4,4,7,7,8,8,10,10,10,9],
        [4,1,1,7,7,8,8,8,1,1,10] // Note: fixed minor ID gap
    ],
    // Set 2: Variation
    [
        [2,2,2,7,7,10,10,10,9,9,9],
        [2,6,6,6,7,7,11,10,10,4,9],
        [5,6,3,3,7,11,11,11,4,4,9],
        [5,6,3,3,8,8,11,1,1,4,0],
        [5,5,5,8,8,8,1,1,0,0,0]
    ],
    // Set 3: Another Variation
    [
        [0,0,0,0,6,6,6,9,9,9,9],
        [1,1,5,5,6,10,10,2,2,2,9],
        [1,1,5,6,10,10,10,8,8,2,7],
        [11,5,5,4,4,4,3,3,8,7,7],
        [11,11,11,11,4,3,3,8,8,7,7]
    ]
];

const COLS = 11;
const ROWS = 5;
let cellSize = 32;
let boardState = [];
let answerKey = [];
let pieces = [];
let pickedPieceIdx = null; // PC: Index of piece currently holding
let lastTapTime = 0; // Mobile: for double tap

const boardEl = document.getElementById('board');
const trayEl = document.getElementById('tray');

// 1. ì´ˆê¸°í™”
function initLayout() {
    const containerWidth = document.getElementById('game-container').offsetWidth;
    // 11ì¹¸ + ì—¬ë°±
    cellSize = Math.floor((containerWidth - 25) / 11);
    if(cellSize > 45) cellSize = 45; // ìµœëŒ€ í¬ê¸° ì œí•œ
    
    document.documentElement.style.setProperty('--cell-size', `${cellSize}px`);
    createGrid();
    if(pieces.length > 0) renderPieces();
}

function createGrid() {
    boardEl.innerHTML = '';
    for(let i=0; i<ROWS*COLS; i++) {
        const div = document.createElement('div');
        div.className = 'cell';
        boardEl.appendChild(div);
    }
}

// 2. ê²Œì„ ë¡œë“œ
function loadNewGame() {
    if(pickedPieceIdx !== null) releasePiece(); // ë“¤ê³  ìˆëŠ”ê²Œ ìˆìœ¼ë©´ ë†“ê¸°

    const randIdx = Math.floor(Math.random() * SOLUTION_DB.length);
    // Deep Copy
    answerKey = JSON.parse(JSON.stringify(SOLUTION_DB[randIdx]));
    boardState = JSON.parse(JSON.stringify(answerKey));
    
    extractPiecesFromBoard();
    applyDifficulty();
    renderPieces();
    showMessage("ìƒˆë¡œìš´ ê²Œì„ ì‹œì‘! ğŸš€");
}

function extractPiecesFromBoard() {
    pieces = [];
    for(let id=0; id<12; id++) {
        let coords = [];
        for(let r=0; r<ROWS; r++) {
            for(let c=0; c<COLS; c++) {
                if(boardState[r][c] === id) coords.push({r, c});
            }
        }
        
        if(coords.length === 0) continue;

        const minR = Math.min(...coords.map(p=>p.r));
        const maxR = Math.max(...coords.map(p=>p.r));
        const minC = Math.min(...coords.map(p=>p.c));
        const maxC = Math.max(...coords.map(p=>p.c));
        
        const height = maxR - minR + 1;
        const width = maxC - minC + 1;
        
        let shape = Array(height).fill().map(()=>Array(width).fill(0));
        coords.forEach(p => {
            shape[p.r - minR][p.c - minC] = 1;
        });

        pieces.push({
            id: id,
            color: SHAPES_DEF[id].color,
            currentShape: shape,
            x: minC, y: minR,
            isLocked: true 
        });
    }
}

function applyDifficulty() {
    const keepCount = parseInt(document.getElementById('difficulty').value);
    let allIndices = pieces.map((_, i) => i);
    let lockedIndices = [];
    
    for(let i=0; i<keepCount; i++) {
        if(allIndices.length === 0) break;
        let r = Math.floor(Math.random() * allIndices.length);
        lockedIndices.push(allIndices[r]);
        allIndices.splice(r, 1);
    }

    pieces.forEach((p, idx) => {
        if(lockedIndices.includes(idx)) {
            p.isLocked = true;
        } else {
            p.isLocked = false;
            removePieceFromBoardState(p.currentShape, p.y, p.x);
            p.x = -1; p.y = -1;
        }
    });
}

function removePieceFromBoardState(shape, r, c) {
    for(let i=0; i<shape.length; i++) {
        for(let j=0; j<shape[0].length; j++) {
            if(shape[i][j] === 1) boardState[r+i][c+j] = -1;
        }
    }
}

// 3. ë Œë”ë§
function renderPieces() {
    // ê¸°ì¡´ ì¡°ê° ì œê±° (pickedPiece ì œì™¸)
    document.querySelectorAll('.piece').forEach(e => {
        if(pickedPieceIdx === null || e.id !== `p-${pickedPieceIdx}`) e.remove();
    });

    pieces.forEach((p, idx) => {
        // ì´ë¯¸ DOMì— ìˆê³  ë“¤ê³  ìˆëŠ” ì¡°ê°ì€ ê±´ë„ˆëœ€
        if(pickedPieceIdx === idx && document.getElementById(`p-${idx}`)) return;

        const el = document.createElement('div');
        el.className = `piece ${p.x===-1?'in-tray':''} ${p.isLocked?'locked':''}`;
        el.id = `p-${idx}`;
        el.style.gridTemplateColumns = `repeat(${p.currentShape[0].length}, 1fr)`;
        
        p.currentShape.forEach(row => {
            row.forEach(v => {
                const b = document.createElement('div');
                if(v) { b.className = 'block'; b.style.backgroundColor = p.color; }
                else b.style.visibility = 'hidden';
                el.appendChild(b);
            });
        });

        if(p.x !== -1) placeOnBoard(el, p.x, p.y);
        else trayEl.appendChild(el);

        if(!p.isLocked) {
            setupInteraction(el, idx);
        }
    });
}

function placeOnBoard(el, x, y) {
    const gap = 2;
    const left = 10 + x * (cellSize + gap);
    const top = 10 + y * (cellSize + gap);
    el.style.left = `${left}px`;
    el.style.top = `${top}px`;
    el.style.position = 'absolute';
    boardEl.appendChild(el);
}

// 4. í†µí•© ì¸í„°ë™ì…˜ í•¸ë“¤ëŸ¬ (PC & Mobile)
function setupInteraction(el, idx) {
    // PC Events
    el.addEventListener('mousedown', (e) => handleMouseDown(e, idx, el));
    // Mobile Events
    el.addEventListener('touchstart', (e) => handleTouchStart(e, idx, el), {passive: false});
}

// --- PC Logic (Click to Pick/Drop, Wheel, RightClick) ---
function handleMouseDown(e, idx, el) {
    if(e.button !== 0) return; // Only Left Click for pickup
    e.stopPropagation();

    if(pickedPieceIdx === null) {
        // Pick up
        pickUpPiece(idx, el, e.clientX, e.clientY);
    } else if (pickedPieceIdx === idx) {
        // Drop (Click again on same piece)
        dropPiece(idx, el, e.clientX, e.clientY);
    } else {
        // Switch piece
        // 1. Drop current
        const oldIdx = pickedPieceIdx;
        const oldEl = document.getElementById(`p-${oldIdx}`);
        dropPiece(oldIdx, oldEl, e.clientX, e.clientY);
        // 2. Pick new
        pickUpPiece(idx, el, e.clientX, e.clientY);
    }
}

function pickUpPiece(idx, el, startX, startY) {
    pickedPieceIdx = idx;
    el.classList.add('picked-up');
    el.classList.remove('in-tray');
    document.body.appendChild(el); // Move to body for free movement
    
    // Initial pos
    moveAt(el, startX, startY);

    // Global Listeners
    document.addEventListener('mousemove', onMouseMove);
    document.addEventListener('wheel', onWheel, {passive: false});
    document.addEventListener('contextmenu', onRightClick);
    document.addEventListener('mousedown', onGlobalClick); // To detect click on empty space to drop
}

function moveAt(el, pageX, pageY) {
    // Center the piece under cursor
    const rect = el.getBoundingClientRect();
    el.style.left = `${pageX - rect.width/2}px`;
    el.style.top = `${pageY - rect.height/2}px`;
}

function onMouseMove(e) {
    if(pickedPieceIdx !== null) {
        const el = document.getElementById(`p-${pickedPieceIdx}`);
        moveAt(el, e.clientX, e.clientY);
    }
}

function onWheel(e) {
    if(pickedPieceIdx !== null) {
        e.preventDefault();
        rotatePieceData(pickedPieceIdx);
    }
}

function onRightClick(e) {
    if(pickedPieceIdx !== null) {
        e.preventDefault();
        flipPieceData(pickedPieceIdx);
    }
}

function onGlobalClick(e) {
    // If clicking outside the piece, try to drop
    if(pickedPieceIdx !== null) {
        // Ignore if clicked on the piece itself (handled by its mousedown)
        if(e.target.closest(`#p-${pickedPieceIdx}`)) return;
        
        const el = document.getElementById(`p-${pickedPieceIdx}`);
        dropPiece(pickedPieceIdx, el, e.clientX, e.clientY);
    }
}

function releasePiece() {
    if(pickedPieceIdx !== null) {
        const el = document.getElementById(`p-${pickedPieceIdx}`);
        // Force return to tray or current valid pos
        // Simple re-render handles logic
        pickedPieceIdx = null;
        renderPieces();
        cleanupListeners();
    }
}

function dropPiece(idx, el, clientX, clientY) {
    const bRect = boardEl.getBoundingClientRect();
    const p = pieces[idx];
    
    // Check if over board
    if(clientX > bRect.left && clientX < bRect.right && 
       clientY > bRect.top && clientY < bRect.bottom) {
        
        const gap = 2;
        // Calculate grid pos
        const elRect = el.getBoundingClientRect();
        // Offset to match cell center
        const relX = elRect.left - bRect.left - 10;
        const relY = elRect.top - bRect.top - 10;
        
        const gx = Math.round(relX / (cellSize + gap));
        const gy = Math.round(relY / (cellSize + gap));

        if(p.x !== -1) removePieceFromBoardState(p.currentShape, p.y, p.x);

        if(canPlace(p.currentShape, gy, gx)) {
            placePieceToBoardState(p.currentShape, gy, gx, p.id);
            p.x = gx; p.y = gy;
        } else {
            // Invalid placement -> Back to tray
            p.x = -1; p.y = -1;
        }
    } else {
        // Dropped outside board -> Back to tray
        if(p.x !== -1) removePieceFromBoardState(p.currentShape, p.y, p.x);
        p.x = -1; p.y = -1;
    }

    pickedPieceIdx = null;
    cleanupListeners();
    renderPieces(); // Re-render to snap to grid/tray
}

function cleanupListeners() {
    document.removeEventListener('mousemove', onMouseMove);
    document.removeEventListener('wheel', onWheel);
    document.removeEventListener('contextmenu', onRightClick);
    document.removeEventListener('mousedown', onGlobalClick);
}


// --- Mobile Logic (Drag, Tap to Rotate, Double Tap to Flip) ---
let isDragging = false;
let dragStartX = 0, dragStartY = 0;
let initialElX = 0, initialElY = 0;

function handleTouchStart(e, idx, el) {
    if(e.touches.length > 1) return; // Ignore multitouch
    e.preventDefault();
    
    const touch = e.touches[0];
    const currentTime = new Date().getTime();
    const tapLength = currentTime - lastTapTime;
    
    // Double Tap Detection (Flip)
    if(tapLength < 300 && tapLength > 0) {
        flipPieceData(idx);
        lastTapTime = 0;
        return;
    }
    lastTapTime = currentTime;

    // Start Drag
    isDragging = false;
    dragStartX = touch.clientX;
    dragStartY = touch.clientY;
    
    pickedPieceIdx = idx; // Mobile track
    el.classList.add('picked-up');
    el.classList.remove('in-tray');
    document.body.appendChild(el);
    
    // Initial absolute position
    moveAt(el, touch.clientX, touch.clientY);

    // Add Move/End listeners
    const onTouchMove = (ev) => {
        ev.preventDefault();
        isDragging = true;
        moveAt(el, ev.touches[0].clientX, ev.touches[0].clientY);
    };

    const onTouchEnd = (ev) => {
        document.removeEventListener('touchmove', onTouchMove);
        document.removeEventListener('touchend', onTouchEnd);
        el.classList.remove('picked-up');

        if(!isDragging) {
            // It was a single tap -> Rotate
            rotatePieceData(idx);
            // Return visual state
            pickedPieceIdx = null;
            renderPieces();
        } else {
            // It was a drag -> Drop
            const lastTouch = ev.changedTouches[0];
            dropPiece(idx, el, lastTouch.clientX, lastTouch.clientY);
        }
    };

    document.addEventListener('touchmove', onTouchMove, {passive: false});
    document.addEventListener('touchend', onTouchEnd);
}


// --- Logic Utils ---
function rotatePieceData(idx) {
    const p = pieces[idx];
    const oldShape = p.currentShape;
    const newShape = rotateMatrix(oldShape);
    
    // If in tray, just rotate
    if(p.x === -1) {
        p.currentShape = newShape;
    } else {
        // Check valid on board
        removePieceFromBoardState(oldShape, p.y, p.x);
        if(canPlace(newShape, p.y, p.x)) {
            placePieceToBoardState(newShape, p.y, p.x, p.id);
            p.currentShape = newShape;
        } else {
            placePieceToBoardState(oldShape, p.y, p.x, p.id); // Revert
        }
    }
    // Update visual only (no full re-render needed usually, but safe)
    if(pickedPieceIdx === idx) {
        // If holding, update DOM manually to keep holding
        const el = document.getElementById(`p-${idx}`);
        el.style.gridTemplateColumns = `repeat(${p.currentShape[0].length}, 1fr)`;
        el.innerHTML = '';
        p.currentShape.forEach(row => row.forEach(v => {
            const b = document.createElement('div');
            if(v) { b.className = 'block'; b.style.backgroundColor = p.color; }
            else b.style.visibility = 'hidden';
            el.appendChild(b);
        }));
    } else {
        renderPieces();
    }
}

function flipPieceData(idx) {
    const p = pieces[idx];
    const oldShape = p.currentShape;
    // Flip horizontal
    const newShape = oldShape.map(row => [...row].reverse());
    
    if(p.x === -1) {
        p.currentShape = newShape;
    } else {
        removePieceFromBoardState(oldShape, p.y, p.x);
        if(canPlace(newShape, p.y, p.x)) {
            placePieceToBoardState(newShape, p.y, p.x, p.id);
            p.currentShape = newShape;
        } else {
            placePieceToBoardState(oldShape, p.y, p.x, p.id);
        }
    }
    if(pickedPieceIdx === idx) {
        const el = document.getElementById(`p-${idx}`);
        el.innerHTML = ''; // Redraw blocks
        el.style.gridTemplateColumns = `repeat(${p.currentShape[0].length}, 1fr)`;
        p.currentShape.forEach(row => row.forEach(v => {
            const b = document.createElement('div');
            if(v) { b.className = 'block'; b.style.backgroundColor = p.color; }
            else b.style.visibility = 'hidden';
            el.appendChild(b);
        }));
    } else {
        renderPieces();
    }
}

function rotateMatrix(m) {
    const R=m.length, C=m[0].length;
    let n=Array(C).fill().map(()=>Array(R).fill(0));
    for(let r=0; r<R; r++) for(let c=0; c<C; c++) n[c][R-1-r]=m[r][c];
    return n;
}

function canPlace(shape, r, c) {
    for(let i=0; i<shape.length; i++) {
        for(let j=0; j<shape[0].length; j++) {
            if(shape[i][j]) {
                if(r+i>=ROWS || c+j>=COLS || boardState[r+i][c+j]!==-1) return false;
            }
        }
    }
    return true;
}

function placePieceToBoardState(shape, r, c, id) {
    for(let i=0; i<shape.length; i++) for(let j=0; j<shape[0].length; j++) if(shape[i][j]) boardState[r+i][c+j]=id;
}

function checkSolution() {
    let filled=0;
    for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++) if(boardState[r][c]!==-1) filled++;
    if(filled===ROWS*COLS) showMessage("ğŸ‰ ì¶•í•˜í•©ë‹ˆë‹¤! í¼ì¦ ì™„ì„±!");
    else showMessage(`ì•„ì§ ${ROWS*COLS - filled}ì¹¸ì´ ë¹„ì—ˆìŠµë‹ˆë‹¤.`);
}

function showAnswer() {
    if(!confirm("ì •ë‹µì„ í™•ì¸í•˜ë©´ í˜„ì¬ ì§„í–‰ ìƒí™©ì´ ì‚¬ë¼ì§‘ë‹ˆë‹¤.")) return;
    boardState = JSON.parse(JSON.stringify(answerKey));
    extractPiecesFromBoard();
    renderPieces();
}

function showMessage(t) {
    const m=document.getElementById('message');
    m.textContent=t; m.style.display='block';
    setTimeout(()=>m.style.display='none', 1500);
}

window.addEventListener('resize', initLayout);
initLayout();
loadNewGame();
</script>
</body>
</html>
