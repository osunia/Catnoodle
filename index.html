<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>CATNOODLE</title>
    <style>
        :root {
            --bg-color: #f5f6fa;
            --board-bg: #2d3436;
            --hole-color: #151819;
            --tray-bg: #ffffff;
            --primary-btn: #4834d4;
            --secondary-btn: #eb4d4b;
            --text-color: #2d3436;
            --cell-size: 32px;
        }

        * { box-sizing: border-box; }

        body {
            font-family: 'Segoe UI', 'Apple SD Gothic Neo', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            display: flex; flex-direction: column; align-items: center;
            min-height: 100vh; overflow-x: hidden; touch-action: none;
            user-select: none;
            -webkit-user-select: none;
        }

        header { 
            margin: 20px 0 15px; 
            text-align: center; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            gap: 12px;
        }
        
        h1 { margin: 0; font-size: 2rem; color: #2d3436; font-weight: 800; letter-spacing: -1px; }
        
        .btn-help {
            width: 26px; height: 26px;
            border-radius: 50%;
            background: #b2bec3;
            color: white;
            border: none;
            font-weight: bold;
            font-size: 1rem;
            cursor: pointer;
            display: flex; align-items: center; justify-content: center;
            transition: background 0.2s;
        }
        .btn-help:hover { background: #636e72; }

        .controls {
            display: flex; gap: 12px; margin-bottom: 20px;
            flex-wrap: wrap; justify-content: center; z-index: 20;
        }

        select, button.game-btn {
            padding: 10px 18px; border-radius: 8px; border: none; font-size: 0.95rem;
            cursor: pointer; box-shadow: 0 3px 6px rgba(0,0,0,0.1);
            font-weight: 700; color: white; transition: transform 0.1s, box-shadow 0.1s;
        }
        select { background: #636e72; color: white; }
        .btn-gen { background: var(--primary-btn); }
        .btn-check { background: #6ab04c; }
        .btn-answer { background: var(--secondary-btn); }
        button:active { transform: scale(0.97); box-shadow: 0 1px 3px rgba(0,0,0,0.1); }

        #game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 25px;
            width: 95%;
            max-width: 1100px;
            padding: 10px;
        }

        @media (min-width: 850px) {
            #game-container {
                flex-direction: row;
                align-items: flex-start;
                justify-content: center;
            }
            #board { margin-top: 0; }
            #tray { 
                width: 380px; 
                height: 500px; /* ê³ ì • ë†’ì´ */
                overflow-y: auto;
            }
        }

        /* ë³´ë“œ ë””ìì¸ */
        #board {
            display: grid;
            grid-template-columns: repeat(11, var(--cell-size));
            grid-template-rows: repeat(5, var(--cell-size));
            gap: 2px;
            background-color: var(--board-bg);
            padding: 10px; 
            border-radius: 16px;
            box-shadow: 0 15px 35px rgba(0,0,0,0.2);
            position: relative;
            flex-shrink: 0;
            border: 4px solid #dfe6e9;
        }

        .cell {
            width: var(--cell-size); height: var(--cell-size);
            background-color: var(--hole-color);
            border-radius: 50%;
            box-shadow: inset 1px 1px 5px rgba(0,0,0,0.6);
        }

        /* íŠ¸ë ˆì´ ë””ìì¸ ê°œì„  */
        #tray {
            width: 100%;
            min-height: 250px;
            background-color: var(--tray-bg);
            border-radius: 16px;
            padding: 20px;
            display: flex; flex-wrap: wrap;
            align-content: flex-start; 
            justify-content: center; 
            /* ì¡°ê° ê°„ ë°€ë„ ì¡°ì ˆ (ê°„ê²© ë„“í˜) */
            gap: 15px; 
            box-shadow: 0 8px 20px rgba(0,0,0,0.08);
            border: 2px solid #dcdde1;
        }

        /* ì¡°ê° ê³µí†µ ìŠ¤íƒ€ì¼ */
        .piece {
            display: grid; 
            gap: 1px; /* êµ¬ìŠ¬ ê°„ ê°„ê²©ì„ 1pxë¡œ ì¤„ì—¬ ì¼ì²´ê° í–¥ìƒ */
            cursor: grab; 
            touch-action: none; 
            z-index: 100;
            transition: transform 0.1s;
            pointer-events: auto;
        }

        /* ë³´ë“œ ìœ„ ì¡°ê° */
        .piece.on-board {
            position: absolute;
            gap: 2px; /* ë³´ë“œ ìœ„ì—ì„œëŠ” êµ¬ë© ê°„ê²©(2px)ì— ë§ì¶¤ */
        }
        
        /* íŠ¸ë ˆì´ ì•ˆ ì¡°ê° */
        .piece.in-tray { 
            position: relative; 
            transform: scale(0.9); /* ì•½ê°„ë§Œ ì¶•ì†Œ */
            left: auto !important; 
            top: auto !important; 
            margin: 5px; /* ì¡°ê°ë¼ë¦¬ ë‹¿ì§€ ì•Šê²Œ ì—¬ë°± ì¶”ê°€ */
        }

        /* ë“œë˜ê·¸ ì¤‘ì¸ ì¡°ê° */
        .piece.picked-up {
            position: fixed; /* ì ˆëŒ€ ìœ„ì¹˜ */
            cursor: grabbing;
            opacity: 0.95;
            filter: drop-shadow(0 15px 25px rgba(0,0,0,0.3));
            transform: scale(1.05);
            pointer-events: none; 
            z-index: 9999;
            gap: 2px; /* ë“œë˜ê·¸ ì¤‘ì—ëŠ” ë³´ë“œ ê·œê²© ë”°ë¦„ */
        }
        
        .piece.locked { cursor: not-allowed; filter: grayscale(0.2) opacity(0.9); pointer-events: none; }
        
        .block {
            width: var(--cell-size); height: var(--cell-size);
            border-radius: 50%;
            /* í”Œë¼ìŠ¤í‹± êµ¬ìŠ¬ ì§ˆê° ê°•í™” */
            box-shadow: inset -4px -4px 8px rgba(0,0,0,0.25), 
                        inset 3px 3px 8px rgba(255,255,255,0.4), 
                        1px 1px 2px rgba(0,0,0,0.2);
            border: 0.5px solid rgba(0,0,0,0.1);
        }

        /* ëª¨ë‹¬ ìŠ¤íƒ€ì¼ */
        .modal-overlay {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.5); z-index: 3000;
            display: none; justify-content: center; align-items: center;
            backdrop-filter: blur(2px);
        }
        .modal {
            background: white; padding: 30px; border-radius: 16px;
            max-width: 320px; width: 90%; text-align: left;
            box-shadow: 0 15px 40px rgba(0,0,0,0.2);
        }
        .modal h3 { margin-top: 0; margin-bottom: 20px; color: var(--primary-btn); text-align: center; font-size: 1.2rem;}
        .modal ul { padding-left: 0; list-style: none; font-size: 0.95rem; color: #555; line-height: 2.2; margin: 0; }
        .modal li { display: flex; align-items: center; justify-content: space-between; border-bottom: 1px solid #f1f2f6; }
        .modal li:last-child { border-bottom: none; }
        .modal span.key { font-weight: bold; color: #2d3436; background: #dfe6e9; padding: 4px 8px; border-radius: 6px; font-size: 0.85rem;}
        .modal button { margin-top: 25px; background: #2d3436; width: 100%; border-radius: 10px; padding: 12px;}

        #message {
            position: fixed; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(45, 52, 54, 0.95); color: white;
            padding: 16px 32px; border-radius: 50px;
            display: none; z-index: 2000; text-align: center;
            font-weight: 700; box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            font-size: 1.1rem;
        }
    </style>
</head>
<body>

<header>
    <h1>CATNOODLEğŸ˜º</h1>
    <button class="btn-help" onclick="toggleModal()">?</button>
</header>

<div class="controls">
    <select id="difficulty">
        <option value="2">ì‰¬ì›€ (2ê°œ ê³ ì •)</option>
        <option value="4" selected>ë³´í†µ (4ê°œ ê³ ì •)</option>
        <option value="6">ì–´ë ¤ì›€ (6ê°œ ê³ ì •)</option>
    </select>
    <button class="game-btn btn-gen" onclick="loadNewGame()">ìƒì„±</button>
    <button class="game-btn btn-check" onclick="checkSolution()">í™•ì¸</button>
    <button class="game-btn btn-answer" onclick="showAnswer()">ì •ë‹µ</button>
</div>

<div id="game-container">
    <div id="board"></div>
    <div id="tray"></div>
</div>

<div class="modal-overlay" id="helpModal" onclick="toggleModal()">
    <div class="modal" onclick="event.stopPropagation()">
        <h3>ì¡°ì‘ ë°©ë²•</h3>
        <ul>
            <li><span>ì¡°ê° ë“¤ê¸° / ë†“ê¸°</span> <span class="key">í´ë¦­</span></li>
            <li><span>íšŒì „ (90ë„)</span> <span class="key">íœ  / í„°ì¹˜</span></li>
            <li><span>ì¡°ê° ë’¤ì§‘ê¸°</span> <span class="key">ìš°í´ë¦­ / ë”ë¸”íƒ­</span></li>
            <li><span>ì´ë™</span> <span class="key">ë“œë˜ê·¸</span></li>
        </ul>
        <button class="game-btn" onclick="toggleModal()">ë‹«ê¸°</button>
    </div>
</div>

<div id="message"></div>

<script>
// ğŸ› ï¸ 1. ìš°í´ë¦­ ë°©ì§€ & ì œì–´ 
document.addEventListener('contextmenu', event => event.preventDefault());

/**
 * ğŸ› ï¸ SHAPE DEFINITIONS (ì°¨íŠ¸ ì´ë¯¸ì§€ ê¸°ë°˜ ìµœì¢… ìˆ˜ì •)
 * 11x5 = 55ì¹¸ì— ì •í™•íˆ ë§ì¶”ê¸° ìœ„í•´ FëŠ” 3ì¹¸ ì¡°ê°ìœ¼ë¡œ íŒëª…ë¨.
 */
const SHAPES_DEF = [
    // A: Orange (L-Short, 4 units) - ì´ë¯¸ì§€ ê·¸ëŒ€ë¡œ
    { id: 0, color: '#f39c12', shape: [[1,0],[1,0],[1,1]] }, 
    
    // B: Red (P-Pentomino, 5 units) - ì°¨íŠ¸ B ì°¸ì¡°
    { id: 1, color: '#c0392b', shape: [[1,1],[1,1],[0,1]] }, 
    
    // C: Dark Blue (Long L, 5 units) - ì™„ë²½í•œ ã„±ì
    { id: 2, color: '#2980b9', shape: [[1,1,1,1],[1,0,0,0]] }, 
    
    // D: Light Pink (Cross/t, 5 units) - ì°¨íŠ¸ D ì°¸ì¡°
    { id: 3, color: '#ffcccc', shape: [[0,1],[0,1],[1,1],[0,1]] }, 
    
    // E: Green (P-Pentomino, 5 units) - ì°¨íŠ¸ E ì°¸ì¡° (Bì™€ ëª¨ì–‘ ë™ì¼)
    { id: 4, color: '#27ae60', shape: [[1,1],[1,1],[0,1]] }, 
    
    // F: White (Small-L, 3 units) - 55ì¹¸ ë§ì¶¤ì„ ìœ„í•œ í•µì‹¬ ì¡°ê°
    { id: 5, color: '#ffffff', shape: [[1,1],[0,1]] }, 
    
    // G: Light Blue (Big-V, 5 units) - ì°¨íŠ¸ G ì°¸ì¡°
    { id: 6, color: '#82ccdd', shape: [[1,0,0],[1,0,0],[1,1,1]] }, 
    
    // H: Magenta/Pink (W, 5 units) - ì°¨íŠ¸ H ì°¸ì¡°
    { id: 7, color: '#fd79a8', shape: [[1,0,0],[1,1,0],[0,1,1]] }, 
    
    // I: Yellow (U-shape, 5 units) - ì°¨íŠ¸ I ì°¸ì¡°
    { id: 8, color: '#f1c40f', shape: [[1,0,1],[1,1,1]] }, 
    
    // J: Purple (Line, 4 units) - ì°¨íŠ¸ J ì°¸ì¡°
    { id: 9, color: '#8e44ad', shape: [[1],[1],[1],[1]] }, 
    
    // K: Lime (Square, 4 units) - ì°¨íŠ¸ K ì°¸ì¡°
    { id: 10, color: '#b8e994', shape: [[1,1],[1,1]] }, 
    
    // L: Grey (Plus, 5 units) - ì°¨íŠ¸ L ì°¸ì¡°
    { id: 11, color: '#95a5a6', shape: [[0,1,0],[1,1,1],[0,1,0]] } 
];

// Kanoodle 200 Level 6 Puzzle 139 Solution Mapping
const SOLUTION_DB = [
    [
        [7,7,4,4,4,1,1,1,6,6,6], // H H E E E B B B G G G
        [3,7,7,0,4,4,1,1,5,5,6], // D H H A E E B B F F G
        [3,3,7,0,0,0,11,8,8,5,6], // D D H A A A L I I F G
        [3,2,2,2,2,11,11,11,8,10,10], // D C C C C L L L I K K
        [3,2,9,9,9,9,11,8,8,10,10]  // D C J J J J L I I K K
    ]
];

const COLS = 11;
const ROWS = 5;
let cellSize = 32;
let boardState = [];
let answerKey = [];
let pieces = [];
let pickedPieceIdx = null;
let lastTapTime = 0;

const boardEl = document.getElementById('board');
const trayEl = document.getElementById('tray');
const modalEl = document.getElementById('helpModal');

function toggleModal() {
    modalEl.style.display = modalEl.style.display === 'flex' ? 'none' : 'flex';
}

function initLayout() {
    const isDesktop = window.innerWidth >= 850;
    const containerWidth = document.getElementById('game-container').offsetWidth;
    const targetWidth = isDesktop ? 650 : containerWidth;
    
    cellSize = Math.floor((targetWidth - 25) / 11);
    if(cellSize > 50) cellSize = 50; 
    
    document.documentElement.style.setProperty('--cell-size', `${cellSize}px`);
    createGrid();
    if(pieces.length > 0) renderPieces();
}

function createGrid() {
    boardEl.innerHTML = '';
    for(let i=0; i<ROWS*COLS; i++) {
        const div = document.createElement('div');
        div.className = 'cell';
        boardEl.appendChild(div);
    }
}

function loadNewGame() {
    if(pickedPieceIdx !== null) releasePiece();
    const randIdx = 0; 
    answerKey = JSON.parse(JSON.stringify(SOLUTION_DB[randIdx]));
    boardState = JSON.parse(JSON.stringify(answerKey));
    extractPiecesFromBoard();
    applyDifficulty();
    renderPieces();
    showMessage("ìƒˆë¡œìš´ ê²Œì„ ì‹œì‘!");
}

function extractPiecesFromBoard() {
    pieces = [];
    for(let id=0; id<12; id++) {
        let coords = [];
        for(let r=0; r<ROWS; r++) {
            for(let c=0; c<COLS; c++) {
                if(boardState[r][c] === id) coords.push({r, c});
            }
        }
        if(coords.length === 0) continue;

        const minR = Math.min(...coords.map(p=>p.r));
        const maxR = Math.max(...coords.map(p=>p.r));
        const minC = Math.min(...coords.map(p=>p.c));
        const maxC = Math.max(...coords.map(p=>p.c));
        
        const height = maxR - minR + 1;
        const width = maxC - minC + 1;
        
        let shape = Array(height).fill().map(()=>Array(width).fill(0));
        coords.forEach(p => { shape[p.r - minR][p.c - minC] = 1; });

        pieces.push({
            id: id,
            color: SHAPES_DEF[id].color,
            currentShape: shape,
            x: minC, y: minR,
            isLocked: true 
        });
    }
}

function applyDifficulty() {
    const keepCount = parseInt(document.getElementById('difficulty').value);
    let allIndices = pieces.map((_, i) => i);
    let lockedIndices = [];
    for(let i=0; i<keepCount; i++) {
        if(allIndices.length === 0) break;
        let r = Math.floor(Math.random() * allIndices.length);
        lockedIndices.push(allIndices[r]);
        allIndices.splice(r, 1);
    }
    pieces.forEach((p, idx) => {
        if(lockedIndices.includes(idx)) {
            p.isLocked = true;
        } else {
            p.isLocked = false;
            removePieceFromBoardState(p.currentShape, p.y, p.x);
            p.x = -1; p.y = -1;
        }
    });
}

function removePieceFromBoardState(shape, r, c) {
    for(let i=0; i<shape.length; i++) for(let j=0; j<shape[0].length; j++) if(shape[i][j]) boardState[r+i][c+j]=-1;
}

function renderPieces() {
    document.querySelectorAll('.piece').forEach(e => {
        if(pickedPieceIdx === null || e.id !== `p-${pickedPieceIdx}`) e.remove();
    });

    pieces.forEach((p, idx) => {
        if(pickedPieceIdx === idx && document.getElementById(`p-${idx}`)) return;

        const el = document.createElement('div');
        // í´ë˜ìŠ¤ êµ¬ë¶„: ë³´ë“œ ìœ„ vs íŠ¸ë ˆì´ ì•ˆ
        const isInTray = p.x === -1;
        el.className = `piece ${isInTray ? 'in-tray' : 'on-board'} ${p.isLocked?'locked':''}`;
        el.id = `p-${idx}`;
        el.style.gridTemplateColumns = `repeat(${p.currentShape[0].length}, 1fr)`;
        
        p.currentShape.forEach(row => {
            row.forEach(v => {
                const b = document.createElement('div');
                if(v) { b.className = 'block'; b.style.backgroundColor = p.color; }
                else b.style.visibility = 'hidden';
                el.appendChild(b);
            });
        });

        if(!isInTray) placeOnBoard(el, p.x, p.y);
        else trayEl.appendChild(el);

        if(!p.isLocked) setupInteraction(el, idx);
    });
}

function placeOnBoard(el, x, y) {
    const gap = 2; 
    const padding = 10; 
    const left = padding + x * (cellSize + gap);
    const top = padding + y * (cellSize + gap);
    el.style.left = `${left}px`;
    el.style.top = `${top}px`;
    boardEl.appendChild(el);
}

function setupInteraction(el, idx) {
    el.addEventListener('mousedown', (e) => handleMouseDown(e, idx, el));
    el.addEventListener('touchstart', (e) => handleTouchStart(e, idx, el), {passive: false});
}

// ğŸ–±ï¸ PC í•¸ë“¤ëŸ¬
function handleMouseDown(e, idx, el) {
    e.stopPropagation();

    // ìš°í´ë¦­: ì¦‰ì‹œ ë’¤ì§‘ê¸°
    if(e.button === 2) {
        flipPieceData(idx);
        return;
    }

    if(e.button !== 0) return; // ì¢Œí´ë¦­ë§Œ í—ˆìš©
    
    if(pickedPieceIdx === null) pickUpPiece(idx, el, e.clientX, e.clientY);
    else if (pickedPieceIdx === idx) dropPiece(idx, el, e.clientX, e.clientY);
    else {
        dropPiece(pickedPieceIdx, document.getElementById(`p-${pickedPieceIdx}`), e.clientX, e.clientY);
        pickUpPiece(idx, el, e.clientX, e.clientY);
    }
}

function pickUpPiece(idx, el, startX, startY) {
    pickedPieceIdx = idx;
    // í´ë˜ìŠ¤ êµì²´ë¡œ ìŠ¤íƒ€ì¼ ë³€ê²½ (z-index, fixed position ë“±)
    el.classList.remove('in-tray', 'on-board');
    el.classList.add('picked-up');
    
    document.body.appendChild(el);
    moveAt(el, startX, startY);

    document.addEventListener('mousemove', onMouseMove);
    document.addEventListener('wheel', onWheel, {passive: false});
    document.addEventListener('mousedown', onGlobalClick);
}

function moveAt(el, pageX, pageY) {
    const rect = el.getBoundingClientRect();
    el.style.left = `${pageX - rect.width/2}px`;
    el.style.top = `${pageY - rect.height/2}px`;
}

function onMouseMove(e) {
    if(pickedPieceIdx !== null) moveAt(document.getElementById(`p-${pickedPieceIdx}`), e.clientX, e.clientY);
}

function onWheel(e) {
    if(pickedPieceIdx !== null) { e.preventDefault(); rotatePieceData(pickedPieceIdx); }
}

function onGlobalClick(e) {
    if(pickedPieceIdx !== null) {
        if(e.button === 2) return; 
        if(e.target.closest(`#p-${pickedPieceIdx}`)) return;
        dropPiece(pickedPieceIdx, document.getElementById(`p-${pickedPieceIdx}`), e.clientX, e.clientY);
    }
}

function releasePiece() {
    if(pickedPieceIdx !== null) {
        pickedPieceIdx = null; renderPieces(); cleanupListeners();
    }
}

function dropPiece(idx, el, clientX, clientY) {
    const bRect = boardEl.getBoundingClientRect();
    const p = pieces[idx];
    
    if(clientX > bRect.left && clientX < bRect.right && clientY > bRect.top && clientY < bRect.bottom) {
        const gap = 2;
        const relX = el.getBoundingClientRect().left - bRect.left - 10;
        const relY = el.getBoundingClientRect().top - bRect.top - 10;
        
        const gx = Math.round(relX / (cellSize + gap));
        const gy = Math.round(relY / (cellSize + gap));

        if(p.x !== -1) removePieceFromBoardState(p.currentShape, p.y, p.x);

        if(canPlace(p.currentShape, gy, gx)) {
            placePieceToBoardState(p.currentShape, gy, gx, p.id);
            p.x = gx; p.y = gy;
        } else {
            p.x = -1; p.y = -1;
        }
    } else {
        if(p.x !== -1) removePieceFromBoardState(p.currentShape, p.y, p.x);
        p.x = -1; p.y = -1;
    }

    pickedPieceIdx = null;
    cleanupListeners();
    renderPieces();
}

function cleanupListeners() {
    document.removeEventListener('mousemove', onMouseMove);
    document.removeEventListener('wheel', onWheel);
    document.removeEventListener('mousedown', onGlobalClick);
}

// ğŸ“± Mobile Logic
function handleTouchStart(e, idx, el) {
    if(e.touches.length > 1) return;
    e.preventDefault();
    const touch = e.touches[0];
    const currentTime = new Date().getTime();
    
    if(currentTime - lastTapTime < 300) { flipPieceData(idx); lastTapTime = 0; return; }
    lastTapTime = currentTime;

    isDragging = false;
    pickedPieceIdx = idx;
    
    el.classList.remove('in-tray', 'on-board');
    el.classList.add('picked-up');
    
    document.body.appendChild(el);
    moveAt(el, touch.clientX, touch.clientY);

    const onTouchMove = (ev) => {
        ev.preventDefault(); isDragging = true;
        moveAt(el, ev.touches[0].clientX, ev.touches[0].clientY);
    };
    const onTouchEnd = (ev) => {
        document.removeEventListener('touchmove', onTouchMove);
        document.removeEventListener('touchend', onTouchEnd);
        el.classList.remove('picked-up');

        if(!isDragging) { rotatePieceData(idx); pickedPieceIdx = null; renderPieces(); }
        else {
            const lastTouch = ev.changedTouches[0];
            dropPiece(idx, el, lastTouch.clientX, lastTouch.clientY);
        }
    };
    document.addEventListener('touchmove', onTouchMove, {passive: false});
    document.addEventListener('touchend', onTouchEnd);
}

// Core Logic
function rotatePieceData(idx) {
    const p = pieces[idx];
    const oldShape = p.currentShape;
    const newShape = rotateMatrix(oldShape);
    updatePieceShape(idx, p, oldShape, newShape);
}

function flipPieceData(idx) {
    const p = pieces[idx];
    const oldShape = p.currentShape;
    const newShape = oldShape.map(row => [...row].reverse());
    updatePieceShape(idx, p, oldShape, newShape);
}

function updatePieceShape(idx, p, oldShape, newShape) {
    if(p.x === -1) {
        p.currentShape = newShape;
    } else {
        removePieceFromBoardState(oldShape, p.y, p.x);
        if(canPlace(newShape, p.y, p.x)) {
            placePieceToBoardState(newShape, p.y, p.x, p.id);
            p.currentShape = newShape;
        } else {
            placePieceToBoardState(oldShape, p.y, p.x, p.id);
        }
    }
    // ì‹œê°ì  ì¦‰ì‹œ ì—…ë°ì´íŠ¸ (ë“¤ê³  ìˆëŠ” ë™ì•ˆ)
    if(pickedPieceIdx === idx) {
        const el = document.getElementById(`p-${idx}`);
        el.style.gridTemplateColumns = `repeat(${p.currentShape[0].length}, 1fr)`;
        el.innerHTML = '';
        p.currentShape.forEach(row => row.forEach(v => {
            const b = document.createElement('div');
            if(v) { b.className = 'block'; b.style.backgroundColor = p.color; }
            else b.style.visibility = 'hidden';
            el.appendChild(b);
        }));
    } else renderPieces();
}

function rotateMatrix(m) {
    const R=m.length, C=m[0].length;
    let n=Array(C).fill().map(()=>Array(R).fill(0));
    for(let r=0; r<R; r++) for(let c=0; c<C; c++) n[c][R-1-r]=m[r][c];
    return n;
}

function canPlace(shape, r, c) {
    for(let i=0; i<shape.length; i++) for(let j=0; j<shape[0].length; j++) 
        if(shape[i][j] && (r+i>=ROWS || c+j>=COLS || boardState[r+i][c+j]!==-1)) return false;
    return true;
}
function placePieceToBoardState(shape, r, c, id) {
    for(let i=0; i<shape.length; i++) for(let j=0; j<shape[0].length; j++) if(shape[i][j]) boardState[r+i][c+j]=id;
}
function checkSolution() {
    let filled=0; for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++) if(boardState[r][c]!==-1) filled++;
    filled===ROWS*COLS ? showMessage("ì¶•í•˜í•©ë‹ˆë‹¤! CATNOODLE ì •ë³µ!") : showMessage(`ì•„ì§ ${ROWS*COLS - filled}ì¹¸ì´ ë¹„ì—ˆìŠµë‹ˆë‹¤.`);
}
function showAnswer() {
    if(!confirm("ì •ë‹µì„ í™•ì¸í•˜ì‹œê² ìŠµë‹ˆê¹Œ?")) return;
    boardState = JSON.parse(JSON.stringify(answerKey));
    extractPiecesFromBoard(); renderPieces();
}
function showMessage(t) {
    const m=document.getElementById('message'); m.textContent=t; m.style.display='block';
    setTimeout(()=>m.style.display='none', 1500);
}

window.addEventListener('resize', initLayout);
initLayout();
loadNewGame();
</script>
</body>
</html>
