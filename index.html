<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Kanoodle Puzzle Generator (DB Ver)</title>
    <style>
        :root {
            --bg-color: #f0f4f8;
            --board-bg: #2c3e50;
            --hole-color: #1a252f;
            --tray-bg: #ffffff;
            --primary-btn: #3498db;
            --secondary-btn: #e74c3c;
            --text-color: #333;
            --cell-size: 32px;
        }

        body {
            font-family: 'Segoe UI', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            display: flex; flex-direction: column; align-items: center;
            min-height: 100vh; overflow-x: hidden; touch-action: none;
        }

        header { margin: 15px 0; text-align: center; }
        h1 { margin: 0; font-size: 1.5rem; color: var(--board-bg); }
        p { margin: 5px 0 0; font-size: 0.9rem; color: #666; }

        .controls {
            display: flex; gap: 8px; margin-bottom: 10px;
            flex-wrap: wrap; justify-content: center;
        }

        select, button {
            padding: 8px 14px; border-radius: 20px; border: none; font-size: 0.9rem;
            cursor: pointer; box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            font-weight: 600;
        }
        .btn-gen { background: var(--primary-btn); color: white; }
        .btn-check { background: #27ae60; color: white; }
        .btn-answer { background: var(--secondary-btn); color: white; }

        #game-container {
            display: flex; flex-direction: column; align-items: center;
            gap: 15px; width: 100%; max-width: 600px;
        }

        #board {
            display: grid;
            grid-template-columns: repeat(11, var(--cell-size));
            grid-template-rows: repeat(5, var(--cell-size));
            gap: 2px;
            background-color: var(--board-bg);
            padding: 10px; border-radius: 10px;
            box-shadow: 0 10px 20px rgba(0,0,0,0.2);
            position: relative;
        }

        .cell {
            width: var(--cell-size); height: var(--cell-size);
            background-color: var(--hole-color);
            border-radius: 50%;
            box-shadow: inset 2px 2px 5px rgba(0,0,0,0.5);
        }

        #tray {
            width: 95%; min-height: 140px;
            background-color: var(--tray-bg);
            border-radius: 15px; padding: 10px;
            display: flex; flex-wrap: wrap;
            justify-content: center; align-items: center; gap: 10px;
            box-shadow: 0 -5px 15px rgba(0,0,0,0.05);
            margin-bottom: 30px;
        }

        .piece {
            position: absolute; display: grid; gap: 2px;
            cursor: grab; touch-action: none; z-index: 10;
            transition: transform 0.1s;
        }
        .piece.in-tray { position: relative; transform: scale(0.75); }
        .piece.locked { cursor: default; filter: brightness(0.7); pointer-events: none; }
        
        .block {
            width: var(--cell-size); height: var(--cell-size);
            border-radius: 50%;
            box-shadow: inset -2px -2px 4px rgba(0,0,0,0.2), 2px 2px 4px rgba(255,255,255,0.3);
            border: 1px solid rgba(0,0,0,0.1);
        }

        #message {
            position: fixed; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.85); color: white;
            padding: 15px 25px; border-radius: 30px;
            display: none; z-index: 2000; text-align: center;
        }
    </style>
</head>
<body>

<header>
    <h1>ğŸ§© ì¹´ëˆ„ë“¤ ë§ˆìŠ¤í„° DB</h1>
    <p>ë¹ˆì¹¸ì„ ì±„ì›Œ í¼ì¦ì„ ì™„ì„±í•˜ì„¸ìš”!</p>
</header>

<div class="controls">
    <select id="difficulty">
        <option value="2">ì‰¬ì›€ (2ê°œ ê³ ì •)</option>
        <option value="4" selected>ë³´í†µ (4ê°œ ê³ ì •)</option>
        <option value="6">ì–´ë ¤ì›€ (6ê°œ ê³ ì •)</option>
    </select>
    <button class="btn-gen" onclick="loadNewGame()">ğŸ”„ ìƒˆ ë¬¸ì œ</button>
    <button class="btn-check" onclick="checkSolution()">âœ¨ ì±„ì </button>
    <button class="btn-answer" onclick="showAnswer()">ğŸ‘€ ì •ë‹µ</button>
</div>

<div id="game-container">
    <div id="board"></div>
    <div id="tray"></div>
</div>

<div id="message"></div>

<script>
/**
 * ğŸ’¾ SOLUTION DATABASE
 * ì—¬ê¸°ì— ê³ ê°ë‹˜ì˜ í•´ë‹µ ë°ì´í„°ë¥¼ ì¶”ê°€í•˜ë©´ ë©ë‹ˆë‹¤.
 * í˜•ì‹: 11x5 2ì°¨ì› ë°°ì—´ (ê° ìˆ«ìëŠ” ì¡°ê° ID 0~11)
 */
const SOLUTION_DB = [
    // [ì˜ˆì‹œ ë°ì´í„° 1] - í…ŒìŠ¤íŠ¸ë¥¼ ìœ„í•´ ì„ì˜ë¡œ ë§Œë“  íŒ¨í„´ì…ë‹ˆë‹¤. 
    // ì‹¤ì œ ë°ì´í„°ê°€ ë“¤ì–´ì˜¤ë©´ ì´ ë¶€ë¶„ì„ êµì²´í•©ë‹ˆë‹¤.
    [
        [0,0,0,0,0, 1,1, 2,2,2, 3],
        [4,4,4,4, 5, 1,1, 2, 6, 3,3],
        [7,7,7, 5,5, 8, 8, 6,6, 9, 3],
        [7,7, 10,10, 5, 8,8,8, 6, 9,9],
        [11,11,11, 10,10,10, 11,11, 6, 9,9] 
    ]
    // ... ì—¬ê¸°ì— ì½¤ë§ˆ(,)ë¡œ êµ¬ë¶„í•˜ì—¬ ì¶”ê°€ ë°ì´í„°ë¥¼ ê³„ì† ë„£ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
];

/**
 * ğŸ¨ ì¡°ê° ì •ì˜ (IDì™€ ìƒ‰ìƒ ë§¤ì¹­ìš©)
 * ì‹¤ì œ ëª¨ì–‘ ë°ì´í„°ëŠ” DBì—ì„œ ë¡œë“œëœ ë°°ì¹˜ í˜•íƒœë¥¼ ê¸°ë°˜ìœ¼ë¡œ ì—­ì‚°ì¶œí•©ë‹ˆë‹¤.
 */
const SHAPES_META = [
    { id: 0, color: '#FF6B6B' }, 
    { id: 1, color: '#4ECDC4' },
    { id: 2, color: '#45B7D1' },
    { id: 3, color: '#96CEB4' },
    { id: 4, color: '#FFEEAD' },
    { id: 5, color: '#D4A5A5' },
    { id: 6, color: '#9B59B6' },
    { id: 7, color: '#3498DB' },
    { id: 8, color: '#E67E22' },
    { id: 9, color: '#1ABC9C' },
    { id: 10, color: '#F1C40F' },
    { id: 11, color: '#E74C3C' }
];

// ê²Œì„ ìƒíƒœ ë³€ìˆ˜
const COLS = 11;
const ROWS = 5;
let cellSize = 32;
let boardState = []; // í˜„ì¬ ë³´ë“œ ìƒíƒœ (-1: ë¹ˆì¹¸, 0~11: ì¡°ê° ID)
let answerKey = [];  // í˜„ì¬ ë¬¸ì œì˜ ì •ë‹µì§€
let pieces = [];     // ì¡°ê° ê°ì²´ (í˜„ì¬ ìœ„ì¹˜, í˜•íƒœ ë“± ì •ë³´)

// DOM
const boardEl = document.getElementById('board');
const trayEl = document.getElementById('tray');

// 1. ì´ˆê¸°í™”
function initLayout() {
    const containerWidth = document.getElementById('game-container').offsetWidth;
    cellSize = Math.floor((containerWidth - 25) / 11); // ì—¬ë°± ë³´ì •
    if(cellSize > 40) cellSize = 40;
    
    document.documentElement.style.setProperty('--cell-size', `${cellSize}px`);
    createGrid();
    if(pieces.length > 0) renderPieces(); // ë¦¬ì‚¬ì´ì¦ˆ ì‹œ ë‹¤ì‹œ ê·¸ë¦¬ê¸°
}

function createGrid() {
    boardEl.innerHTML = '';
    for(let i=0; i<ROWS*COLS; i++) {
        const div = document.createElement('div');
        div.className = 'cell';
        boardEl.appendChild(div);
    }
}

// 2. ìƒˆ ê²Œì„ ë¡œë“œ (DBì—ì„œ ê°€ì ¸ì˜¤ê¸°)
function loadNewGame() {
    // DBì—ì„œ ëœë¤ ì„ íƒ
    if(SOLUTION_DB.length === 0) {
        alert("ë°ì´í„°ë² ì´ìŠ¤ê°€ ë¹„ì–´ìˆìŠµë‹ˆë‹¤!");
        return;
    }
    const randIdx = Math.floor(Math.random() * SOLUTION_DB.length);
    const selectedData = SOLUTION_DB[randIdx];

    // ì •ë‹µ í‚¤ ë³µì‚¬ (Deep Copy)
    answerKey = JSON.parse(JSON.stringify(selectedData));
    
    // ë³´ë“œ ì´ˆê¸°í™” (ì¼ë‹¨ ì •ë‹µìœ¼ë¡œ ë‹¤ ì±„ì›€)
    boardState = JSON.parse(JSON.stringify(answerKey));
    
    // ì¡°ê° ì •ë³´ ì¶”ì¶œ (ì—­ë°©í–¥ ìƒì„±ì˜ í•µì‹¬: ë°°ì¹˜ëœ ìƒíƒœì—ì„œ ì¡°ê° ëª¨ì–‘ì„ ë– ëƒ„)
    extractPiecesFromBoard();
    
    // ë‚œì´ë„ ì ìš© (ì¼ë¶€ ì¡°ê° ë“¤ì–´ë‚´ê¸°)
    applyDifficulty();
    
    renderPieces();
    showMessage("ìƒˆë¡œìš´ ë¬¸ì œê°€ ì¶œì œë˜ì—ˆìŠµë‹ˆë‹¤! ğŸš€");
}

// ë°°ì¹˜ëœ ë³´ë“œ ìƒíƒœì—ì„œ ê° ì¡°ê°ì˜ ëª¨ì–‘ê³¼ ìœ„ì¹˜ë¥¼ ì¶”ì¶œí•˜ëŠ” í•¨ìˆ˜
function extractPiecesFromBoard() {
    pieces = [];
    for(let id=0; id<12; id++) {
        // í•´ë‹¹ IDì˜ ì¢Œí‘œë“¤ ì°¾ê¸°
        let coords = [];
        for(let r=0; r<ROWS; r++) {
            for(let c=0; c<COLS; c++) {
                if(boardState[r][c] === id) coords.push({r, c});
            }
        }
        
        if(coords.length === 0) continue; // ë°ì´í„° ì˜¤ë¥˜ ë°©ì§€

        // Bounding Box ê³„ì‚° (ëª¨ì–‘ ë– ë‚´ê¸°)
        const minR = Math.min(...coords.map(p=>p.r));
        const maxR = Math.max(...coords.map(p=>p.r));
        const minC = Math.min(...coords.map(p=>p.c));
        const maxC = Math.max(...coords.map(p=>p.c));
        
        const height = maxR - minR + 1;
        const width = maxC - minC + 1;
        
        // 2ì°¨ì› ë§¤íŠ¸ë¦­ìŠ¤ ìƒì„±
        let shape = Array(height).fill().map(()=>Array(width).fill(0));
        coords.forEach(p => {
            shape[p.r - minR][p.c - minC] = 1;
        });

        pieces.push({
            id: id,
            color: SHAPES_META[id] ? SHAPES_META[id].color : '#999',
            currentShape: shape,
            x: minC, // í˜„ì¬ ë³´ë“œ ìƒ ìœ„ì¹˜
            y: minR,
            isLocked: true // ì¼ë‹¨ ëª¨ë‘ ì ê¸ˆ ìƒíƒœë¡œ ì‹œì‘
        });
    }
}

// 3. ë‚œì´ë„ ì¡°ì ˆ (í•µì‹¬ ë¡œì§)
function applyDifficulty() {
    const keepCount = parseInt(document.getElementById('difficulty').value);
    
    // ì „ì²´ ì¡°ê° ì¸ë±ìŠ¤
    let allIndices = pieces.map((_, i) => i);
    
    // ìœ ì§€í•  ì¡°ê°(Locked) ëœë¤ ì„ íƒ
    let lockedIndices = [];
    for(let i=0; i<keepCount; i++) {
        if(allIndices.length === 0) break;
        let r = Math.floor(Math.random() * allIndices.length);
        lockedIndices.push(allIndices[r]);
        allIndices.splice(r, 1);
    }

    // ì„ íƒë˜ì§€ ì•Šì€ ì¡°ê°ì€ ë³´ë“œì—ì„œ ì œê±° -> íŠ¸ë ˆì´ë¡œ ì´ë™
    pieces.forEach((p, idx) => {
        if(lockedIndices.includes(idx)) {
            p.isLocked = true;
        } else {
            p.isLocked = false;
            // ë³´ë“œì—ì„œ ì§€ìš°ê¸°
            removePieceFromBoardState(p.currentShape, p.y, p.x);
            p.x = -1; // íŠ¸ë ˆì´ ì¢Œí‘œ
            p.y = -1;
        }
    });
}

function removePieceFromBoardState(shape, r, c) {
    for(let i=0; i<shape.length; i++) {
        for(let j=0; j<shape[0].length; j++) {
            if(shape[i][j] === 1) boardState[r+i][c+j] = -1;
        }
    }
}

// 4. ë Œë”ë§ ë° ì¸í„°ë™ì…˜
function renderPieces() {
    document.querySelectorAll('.piece').forEach(e => e.remove());
    
    pieces.forEach((p, idx) => {
        const el = document.createElement('div');
        el.className = `piece ${p.x===-1?'in-tray':''} ${p.isLocked?'locked':''}`;
        el.style.gridTemplateColumns = `repeat(${p.currentShape[0].length}, 1fr)`;
        
        // ë¸”ë¡ ê·¸ë¦¬ê¸°
        p.currentShape.forEach(row => {
            row.forEach(v => {
                const b = document.createElement('div');
                if(v) { b.className = 'block'; b.style.backgroundColor = p.color; }
                else b.style.visibility = 'hidden';
                el.appendChild(b);
            });
        });

        if(p.x !== -1) placeOnBoard(el, p.x, p.y);
        else trayEl.appendChild(el);

        if(!p.isLocked) {
            el.onpointerdown = (e) => startDrag(e, idx, el);
            el.onclick = (e) => { if(!isDragging) rotatePiece(idx); };
        }
    });
}

function placeOnBoard(el, x, y) {
    const gap = 2;
    const left = 10 + x * (cellSize + gap);
    const top = 10 + y * (cellSize + gap);
    el.style.left = `${left}px`;
    el.style.top = `${top}px`;
    el.style.position = 'absolute';
    boardEl.appendChild(el);
}

// ë“œë˜ê·¸ ì•¤ ë“œë¡­ (ì´ì „ê³¼ ë™ì¼í•œ ë¡œì§, ê°„ì†Œí™”)
let isDragging = false;
function startDrag(e, idx, el) {
    e.preventDefault();
    isDragging = false;
    const startX = e.clientX || e.touches[0].clientX;
    const startY = e.clientY || e.touches[0].clientY;
    const rect = el.getBoundingClientRect();
    const offX = startX - rect.left;
    const offY = startY - rect.top;
    
    el.style.zIndex = 1000;
    el.classList.remove('in-tray');
    document.body.appendChild(el);

    function onMove(ev) {
        if(Math.abs((ev.clientX||ev.touches[0].clientX)-startX)>5) isDragging=true;
        const cx = ev.clientX || ev.touches[0].clientX;
        const cy = ev.clientY || ev.touches[0].clientY;
        el.style.position = 'fixed';
        el.style.left = (cx - offX) + 'px';
        el.style.top = (cy - offY) + 'px';
    }

    function onUp(ev) {
        document.removeEventListener('pointermove', onMove);
        document.removeEventListener('pointerup', onUp);
        
        if(!isDragging) { renderPieces(); return; }

        const bRect = boardEl.getBoundingClientRect();
        const eRect = el.getBoundingClientRect();
        const cx = eRect.left + eRect.width/2;
        const cy = eRect.top + eRect.height/2;

        if(cx>bRect.left && cx<bRect.right && cy>bRect.top && cy<bRect.bottom) {
            const gap = 2;
            const gx = Math.round((eRect.left - bRect.left - 10)/(cellSize+gap));
            const gy = Math.round((eRect.top - bRect.top - 10)/(cellSize+gap));
            
            const p = pieces[idx];
            if(p.x!==-1) removePieceFromBoardState(p.currentShape, p.y, p.x); // ì›ë˜ ìë¦¬ ë¹„ì›€

            if(canPlace(p.currentShape, gy, gx)) {
                placePieceToBoardState(p.currentShape, gy, gx, p.id);
                p.x = gx; p.y = gy;
            } else {
                p.x = -1; // ì‹¤íŒ¨ -> íŠ¸ë ˆì´
            }
        } else {
            const p = pieces[idx];
            if(p.x!==-1) removePieceFromBoardState(p.currentShape, p.y, p.x);
            p.x = -1;
        }
        renderPieces();
    }
    document.addEventListener('pointermove', onMove);
    document.addEventListener('pointerup', onUp);
}

function canPlace(shape, r, c) {
    for(let i=0; i<shape.length; i++) {
        for(let j=0; j<shape[0].length; j++) {
            if(shape[i][j]) {
                if(r+i>=ROWS || c+j>=COLS || boardState[r+i][c+j]!==-1) return false;
            }
        }
    }
    return true;
}
function placePieceToBoardState(shape, r, c, id) {
    for(let i=0; i<shape.length; i++) for(let j=0; j<shape[0].length; j++) if(shape[i][j]) boardState[r+i][c+j]=id;
}

// íšŒì „ ê¸°ëŠ¥
function rotateMatrix(m) {
    const R=m.length, C=m[0].length;
    let n=Array(C).fill().map(()=>Array(R).fill(0));
    for(let r=0; r<R; r++) for(let c=0; c<C; c++) n[c][R-1-r]=m[r][c];
    return n;
}
function rotatePiece(idx) {
    const p = pieces[idx];
    const oldS = p.currentShape;
    const newS = rotateMatrix(oldS);
    
    if(p.x === -1) {
        p.currentShape = newS;
    } else {
        removePieceFromBoardState(oldS, p.y, p.x);
        if(canPlace(newS, p.y, p.x)) {
            placePieceToBoardState(newS, p.y, p.x, p.id);
            p.currentShape = newS;
        } else {
            placePieceToBoardState(oldS, p.y, p.x, p.id); // ë³µêµ¬
            showMessage("ê³µê°„ ë¶€ì¡±! ğŸš«");
        }
    }
    renderPieces();
}

function checkSolution() {
    let filled=0;
    for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++) if(boardState[r][c]!==-1) filled++;
    if(filled===ROWS*COLS) showMessage("ğŸ‰ ì •ë‹µì…ë‹ˆë‹¤!");
    else showMessage("ì•„ì§ ë¹ˆì¹¸ì´ ìˆìŠµë‹ˆë‹¤.");
}

function showAnswer() {
    if(!confirm("ì •ë‹µì„ ë³´ì‹œê² ìŠµë‹ˆê¹Œ?")) return;
    boardState = JSON.parse(JSON.stringify(answerKey));
    extractPiecesFromBoard(); // ìœ„ì¹˜ ë™ê¸°í™”
    renderPieces();
}

function showMessage(t) {
    const m=document.getElementById('message');
    m.textContent=t; m.style.display='block';
    setTimeout(()=>m.style.display='none', 1500);
}

// ì‹œì‘
window.addEventListener('resize', initLayout);
initLayout();
loadNewGame();

</script>
</body>
</html>
